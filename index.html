<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Mobile Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            /* Force fullscreen */
            height: -webkit-fill-available;
            height: fill-available;
        }

        html {
            /* Force fullscreen on mobile */
            height: -webkit-fill-available;
            height: fill-available;
            overflow: hidden;
        }

        /* Fullscreen overlay */
        #fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
            text-align: center;
        }

        #fullscreen-overlay h1 {
            color: #3498db;
            margin-bottom: 30px;
            font-size: 28px;
        }

        #fullscreen-btn, #skip-fullscreen-btn {
            background: #2ecc71;
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            font-weight: 600;
            padding: 15px 30px;
            margin: 20px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
            width: auto;
        }

        #fullscreen-btn:active, #skip-fullscreen-btn:active {
            transform: scale(0.98);
        }

        /* Landscape warning */
        #landscape-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            text-align: center;
        }

        #landscape-warning h1 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #landscape-warning p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #landscape-warning .rotate-icon {
            font-size: 60px;
            margin: 20px 0;
            animation: rotate 2s infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
        }

        /* Main game container */
        #game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            /* Ensure it fills screen */
            height: -webkit-fill-available;
            height: fill-available;
        }

        /* Game layout */
        .game-layout {
            display: flex;
            height: 100%;
            width: 100%;
            background: #2d3436;
        }

        /* Left controls - FIXED WIDTH to prevent overflow */
        #left-controls {
            width: 110px;
            min-width: 110px;
            max-width: 110px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            gap: 6px;
            background: rgba(45, 52, 54, 0.95);
            border-right: 2px solid #34495e;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Mini info */
        .mini-info {
            width: 100%;
            background: rgba(52, 73, 94, 0.7);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            font-size: 11px;
            line-height: 1.2;
            border: 1px solid #2c3e50;
            margin-bottom: 2px;
            box-sizing: border-box;
        }

        .current-player {
            color: #3498db;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .moves-info {
            color: #f39c12;
            font-size: 10px;
        }

        /* Action buttons - FIXED SIZE to fit */
        .action-btn {
            width: 75px;
            min-width: 75px;
            max-width: 75px;
            height: 40px;
            background: #3498db;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            padding: 2px;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .action-btn .icon {
            font-size: 14px;
            margin-bottom: 1px;
        }

        .action-btn.roll { background: #f39c12; }
        .action-btn.aim { background: #e74c3c; }
        .action-btn.shoot { background: #c0392b; }
        .action-btn.end { background: #7f8c8d; }
        .action-btn.info { 
            background: #9b59b6;
            height: 35px;
            margin-top: auto;
        }
        .action-btn.rules { 
            background: #1abc9c;
            height: 35px;
        }
        .action-btn.reset { 
            background: #e67e22;
            height: 35px;
        }

        /* Center game area */
        #center-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
            position: relative;
        }

        /* Canvas container - PERFECTLY CENTERED */
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: #2d3436;
            padding: 0;
            margin: 0;
        }

        canvas {
            display: block;
            background: #2d3436;
            /* Center canvas perfectly */
            margin: auto;
            touch-action: none;
        }

        /* Right controls */
        #right-controls {
            width: 130px;
            min-width: 130px;
            max-width: 130px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 8px 5px;
            gap: 10px;
            background: rgba(45, 52, 54, 0.95);
            border-left: 2px solid #34495e;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Movement D-pad - FIXED POSITION */
        #movement-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 6px;
            background: rgba(52, 73, 94, 0.7);
            padding: 10px;
            border-radius: 20px;
            border: 1px solid #2c3e50;
            width: 90px;
            height: 90px;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .movement-btn {
            width: 45px;
            height: 45px;
            background: #34495e;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            box-sizing: border-box;
        }

        .movement-btn:active {
            background: #2c3e50;
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .movement-btn.up { grid-area: up; }
        .movement-btn.left { grid-area: left; }
        .movement-btn.right { grid-area: right; }
        .movement-btn.down { grid-area: down; }

        /* Weapon info */
        .weapon-info {
            width: 100%;
            background: rgba(52, 73, 94, 0.7);
            border-radius: 8px;
            padding: 6px 4px;
            text-align: center;
            font-size: 10px;
            border: 1px solid #2c3e50;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .weapon-name {
            color: #e74c3c;
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 2px;
        }

        /* Status indicator */
        .status-indicator {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            z-index: 60;
            backdrop-filter: blur(5px);
            border: 1px solid;
            max-width: 90%;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-aiming {
            border-color: yellow;
            color: yellow;
            animation: pulse-status 1s infinite;
        }

        @keyframes pulse-status {
            0%, 100% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
        }

        /* Panels */
        .panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        .panel.active {
            display: flex;
        }

        .panel-content {
            background: rgba(45, 52, 54, 0.95);
            margin: 10px;
            border-radius: 15px;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-height: calc(100vh - 20px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #34495e;
        }

        .panel-header h2 {
            color: #3498db;
            font-size: 18px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 22px;
            cursor: pointer;
            padding: 5px;
        }

        /* Players list */
        .players-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .player-info {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .player-info.current {
            border-left: 4px solid #3498db;
            background: rgba(52, 73, 94, 0.8);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .player-emoji {
            font-size: 18px;
        }

        .player-name {
            font-weight: 600;
            font-size: 14px;
        }

        .player-hp {
            width: 100%;
            height: 5px;
            background: #2c3e50;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }

        .player-hp-bar {
            height: 100%;
            background: #2ecc71;
            border-radius: 3px;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 10px;
            color: #95a5a6;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
            overflow: hidden;
        }

        .stat-label {
            color: #ecf0f1;
            white-space: nowrap;
        }

        /* Aim overlay */
        #aim-overlay, #shotgun-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .aim-cell {
            position: absolute;
            background: rgba(255, 255, 0, 0.3);
            border: 2px solid yellow;
            border-radius: 3px;
            animation: pulse-aim 0.8s infinite;
        }

        @keyframes pulse-aim {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .shotgun-cell {
            position: absolute;
            background: rgba(255, 165, 0, 0.3);
            border: 2px solid orange;
            border-radius: 3px;
        }

        /* Ensure no overflow anywhere */
        body, html, #game-container, .game-layout, #center-game, #canvas-container,
        #left-controls, #right-controls, .mini-info, .weapon-info {
            overflow: hidden !important;
        }

        /* Hide browser UI on mobile */
        @media (display-mode: fullscreen) {
            #game-container {
                height: 100vh;
            }
        }

        /* Very small screens */
        @media (max-height: 500px) {
            #left-controls { width: 91px; min-width: 91px; max-width: 91px; }
            #right-controls { width: 110px; min-width: 110px; max-width: 110px; }
            
            .action-btn {
                width: 65px;
                min-width: 65px;
                max-width: 65px;
                height: 35px;
                font-size: 9px;
            }
            
            .movement-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            #movement-controls {
                width: 80px;
                height: 80px;
                gap: 5px;
            }
            
            .mini-info, .weapon-info {
                font-size: 9px;
            }
        }

        @media (max-width: 650px) {
            #left-controls { width: 85px; min-width: 85px; max-width: 85px; }
            #right-controls { width: 98px; min-width: 98px; max-width: 98px; }
            
            .action-btn {
                width: 60px;
                min-width: 60px;
                max-width: 60px;
                height: 32px;
                font-size: 8px;
            }
            
            .movement-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            #movement-controls {
                width: 70px;
                height: 70px;
                gap: 4px;
            }
        }

        @media (orientation: portrait) {
            #game-container {
                display: none !important;
            }
            #landscape-warning {
                display: flex !important;
            }
        }
    </style>
</head>
<body>
    <!-- Fullscreen overlay -->
    <div id="fullscreen-overlay">
        <h1>üéÆ Mobile Battle Royale</h1>
        <p style="margin-bottom: 20px; font-size: 16px; max-width: 400px;">
            A turn-based tactical combat game for mobile devices.<br>
            For best experience, enable fullscreen mode.
        </p>
        <button id="fullscreen-btn" onclick="enterFullscreen()">
            <span>üì±</span> Enter Fullscreen & Play
        </button>
        <button id="skip-fullscreen-btn" onclick="skipFullscreen()" style="background: #7f8c8d; margin-top: 10px;">
            <span>‚ñ∂Ô∏è</span> Play Without Fullscreen
        </button>
        <div style="margin-top: 25px; padding: 15px; background: rgba(52, 73, 94, 0.5); border-radius: 10px; max-width: 400px; font-size: 13px; line-height: 1.6;">
            <p style="color: #ecf0f1; margin-bottom: 8px;"><strong>‚ÑπÔ∏è To Exit Fullscreen:</strong></p>
            <p style="color: #bdc3c7; margin: 0;">
                <strong>Desktop:</strong> Press <kbd style="background: #34495e; padding: 2px 6px; border-radius: 3px; font-size: 11px;">ESC</kbd> key<br>
                <strong>Mobile:</strong> Swipe down from top or use back button
            </p>
        </div>
        <p style="margin-top: 15px; font-size: 13px; color: #95a5a6;">
            Make sure your device is in landscape mode.
        </p>
    </div>

    <!-- Landscape warning -->
    <div id="landscape-warning">
        <h1>üîÑ Please Rotate Your Device</h1>
        <div class="rotate-icon">üì±</div>
        <p>This game is optimized for landscape mode.<br>Please rotate your device to play.</p>
        <p><small>If rotation doesn't work, check your device's orientation lock.</small></p>
    </div>

    <!-- Main game container -->
    <div id="game-container">
        <!-- Status indicator -->
        <div id="status-indicator" class="status-indicator" style="display: none;"></div>
        
        <div class="game-layout">
            <!-- Left controls -->
            <div id="left-controls">
                <!-- Mini info -->
                <div class="mini-info">
                    <div class="current-player" id="mini-player">P1</div>
                    <div class="moves-info" id="mini-moves">Roll dice!</div>
                </div>
                
                <!-- Action buttons -->
                <button class="action-btn roll" onclick="rollDice()">
                    <span class="icon">üé≤</span>
                    <span>Roll Dice</span>
                </button>
                <button class="action-btn aim" onclick="enterAim()">
                    <span class="icon">üéØ</span>
                    <span>Aim</span>
                </button>
                <button class="action-btn shoot" onclick="shoot()">
                    <span class="icon">üî´</span>
                    <span>Shoot</span>
                </button>
                <button class="action-btn end" onclick="endTurn()">
                    <span class="icon">‚è≠Ô∏è</span>
                    <span>End Turn</span>
                </button>
                
                <!-- Extra buttons -->
                <button class="action-btn info" onclick="showPlayerInfo()">
                    <span class="icon">üë§</span>
                    <span>Players</span>
                </button>
                <button class="action-btn rules" onclick="showRules()">
                    <span class="icon">üìñ</span>
                    <span>Rules</span>
                </button>
                <button class="action-btn reset" onclick="resetGame()">
                    <span class="icon">üîÑ</span>
                    <span>Reset</span>
                </button>
            </div>

            <!-- Center game area -->
            <div id="center-game">
                <!-- Canvas container -->
                <div id="canvas-container">
                    <canvas id="gameCanvas"></canvas>
                    <div id="aim-overlay"></div>
                    <div id="shotgun-preview"></div>
                </div>
            </div>

            <!-- Right controls -->
            <div id="right-controls">
                <!-- Weapon info -->
                <div class="weapon-info">
                    <div class="weapon-name" id="mini-weapon">Pistol</div>
                    <div id="mini-range">Range: 4</div>
                    <div id="mini-damage">Dmg: 20</div>
                </div>
                
                <!-- Movement D-pad -->
                <div id="movement-controls">
                    <button class="movement-btn up" onpointerdown="startMove(0, -1)" onpointerup="stopMove()">‚Üë</button>
                    <button class="movement-btn left" onpointerdown="startMove(-1, 0)" onpointerup="stopMove()">‚Üê</button>
                    <button class="movement-btn right" onpointerdown="startMove(1, 0)" onpointerup="stopMove()">‚Üí</button>
                    <button class="movement-btn down" onpointerdown="startMove(0, 1)" onpointerup="stopMove()">‚Üì</button>
                </div>
            </div>
        </div>

        <!-- Panels -->
        <div id="player-info-panel" class="panel">
            <div class="panel-content">
                <div class="panel-header">
                    <h2>üë• Player Information</h2>
                    <button class="close-btn" onclick="hidePlayerInfo()">‚úï</button>
                </div>
                <div class="players-list" id="players-info"></div>
            </div>
        </div>

        <div id="rules-panel" class="panel">
            <div class="panel-content">
                <div class="panel-header">
                    <h2>üìñ Game Rules</h2>
                    <button class="close-btn" onclick="hideRules()">‚úï</button>
                </div>
                <div id="rules-content" style="flex: 1; overflow-y: auto; padding-right: 5px; font-size: 13px;">
                    <div style="background: rgba(52,73,94,0.5); border-radius: 10px; padding: 12px; margin-bottom: 10px;">
                        <h3 style="color: #3498db; margin-bottom: 8px;">üéØ How to Play</h3>
                        <ul style="padding-left: 20px;">
                            <li><strong>Roll Dice</strong> to get movement points (2-12)</li>
                            <li><strong>Move</strong> your character with the D-pad</li>
                            <li><strong>Aim</strong> at opponents (starts from your position)</li>
                            <li><strong>Shoot</strong> when ready to attack</li>
                            <li><strong>End Turn</strong> when done</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(52,73,94,0.5); border-radius: 10px; padding: 12px; margin-bottom: 10px;">
                        <h3 style="color: #3498db; margin-bottom: 8px;">üè† Houses & Items</h3>
                        <ul style="padding-left: 20px;">
                            <li>Enter <strong>Houses</strong> for loot and cover</li>
                            <li>Inside houses: <strong>Infinite movement</strong></li>
                            <li>Find <strong>Weapons</strong> in crates üì¶</li>
                            <li>Collect <strong>Armor</strong> üõ°Ô∏è for damage reduction</li>
                            <li>Heal with <strong>Food</strong> üçóüçéü•§</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global game instance
        let game = null;

        // Fullscreen functionality
        async function enterFullscreen() {
            const elem = document.documentElement;
            
            try {
                // Try different fullscreen methods
                if (elem.requestFullscreen) {
                    await elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    await elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    await elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    await elem.msRequestFullscreen();
                }
                
                // Fullscreen succeeded - hide overlay and show game
                setTimeout(() => {
                    document.getElementById('fullscreen-overlay').style.display = 'none';
                    checkOrientation();
                    initGame();
                }, 200);
                
            } catch (err) {
                // Fullscreen failed or denied - start game anyway
                console.log('Fullscreen not available or denied:', err);
                document.getElementById('fullscreen-overlay').style.display = 'none';
                checkOrientation();
                initGame();
            }
        }

        // Exit fullscreen (for debugging)
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }

        // Skip fullscreen and start game directly
        function skipFullscreen() {
            document.getElementById('fullscreen-overlay').style.display = 'none';
            checkOrientation();
            initGame();
        }

        // Check orientation
        function checkOrientation() {
            const warning = document.getElementById('landscape-warning');
            const gameContainer = document.getElementById('game-container');
            
            const isLandscape = window.innerWidth > window.innerHeight;
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isLandscape || !isMobile) {
                warning.style.display = 'none';
                gameContainer.style.display = 'block';
                if (game) game.handleResize();
            } else {
                warning.style.display = 'flex';
                gameContainer.style.display = 'none';
            }
        }

        // Game class
        class MobileBattleRoyale {
            constructor() {
                // Core grid constants
                this.GRID_SIZE = 15;
                this.INDOOR_SIZE = 8;
                this.TILE_SIZE = 0;
                this.CANVAS_SIZE = 0;
                
                // Game elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.aimOverlay = document.getElementById('aim-overlay');
                this.shotgunPreview = document.getElementById('shotgun-preview');
                this.statusIndicator = document.getElementById('status-indicator');
                this.canvasContainer = document.getElementById('canvas-container');
                
                // Mini info elements
                this.miniPlayer = document.getElementById('mini-player');
                this.miniMoves = document.getElementById('mini-moves');
                this.miniWeapon = document.getElementById('mini-weapon');
                this.miniRange = document.getElementById('mini-range');
                this.miniDamage = document.getElementById('mini-damage');
                
                // Game state
                this.gameActive = true;
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasRolled = false;
                this.hasShot = false;
                this.aiming = false;
                this.isIndoor = false;
                this.currentHouse = null;
                
                // Movement interval
                this.moveInterval = null;
                this.moveDirection = { dx: 0, dy: 0 };
                
                // Aim state
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                
                // Initialize
                this.initPlayers();
                this.initMap();
                this.initWeapons();
                this.initGear();
                
                // Setup canvas
                this.setupCanvas();
                this.handleResize(); // Position overlays correctly
                this.updateUI();
                this.draw();
            }
            
            setupCanvas() {
                // Get container dimensions
                const container = this.canvasContainer;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate tile size based on available space
                const maxTileSizeByWidth = Math.floor(containerWidth / this.GRID_SIZE);
                const maxTileSizeByHeight = Math.floor(containerHeight / this.GRID_SIZE);
                this.TILE_SIZE = Math.min(maxTileSizeByWidth, maxTileSizeByHeight);
                
                // Ensure minimum visibility
                this.TILE_SIZE = Math.max(this.TILE_SIZE, 25);
                
                // Calculate canvas size
                this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                
                // Set canvas dimensions
                this.canvas.width = this.CANVAS_SIZE;
                this.canvas.height = this.CANVAS_SIZE;
                
                // Setup context
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            handleResize() {
                // Update canvas size
                this.setupCanvas();
                
                // Center canvas perfectly in container
                const container = this.canvasContainer;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate exact center position
                const centerX = (containerWidth - this.CANVAS_SIZE) / 2;
                const centerY = (containerHeight - this.CANVAS_SIZE) / 2;
                
                // Apply centering with pixel-perfect positioning
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = `${Math.max(0, centerX)}px`;
                this.canvas.style.top = `${Math.max(0, centerY)}px`;
                
                // Update overlays to match exactly
                this.aimOverlay.style.position = 'absolute';
                this.aimOverlay.style.left = `${Math.max(0, centerX)}px`;
                this.aimOverlay.style.top = `${Math.max(0, centerY)}px`;
                this.aimOverlay.style.width = `${this.CANVAS_SIZE}px`;
                this.aimOverlay.style.height = `${this.CANVAS_SIZE}px`;
                
                this.shotgunPreview.style.position = 'absolute';
                this.shotgunPreview.style.left = `${Math.max(0, centerX)}px`;
                this.shotgunPreview.style.top = `${Math.max(0, centerY)}px`;
                this.shotgunPreview.style.width = `${this.CANVAS_SIZE}px`;
                this.shotgunPreview.style.height = `${this.CANVAS_SIZE}px`;
                
                // Redraw
                if (this.gameActive) {
                    this.draw();
                    if (this.aiming) {
                        this.updateAimCursor();
                    }
                }
            }
            
            initPlayers() {
                this.players = [
                    {
                        x: 0, y: 14, hp: 100, maxHp: 100,
                        weapon: 'pistol', armor: null, gear: [],
                        alive: true, inHouse: null, indoorPos: null,
                        emoji: 'üòé', color: '#3498db'
                    },
                    {
                        x: 0, y: 0, hp: 100, maxHp: 100,
                        weapon: 'pistol', armor: null, gear: [],
                        alive: true, inHouse: null, indoorPos: null,
                        emoji: 'ü§†', color: '#e74c3c'
                    },
                    {
                        x: 14, y: 0, hp: 100, maxHp: 100,
                        weapon: 'pistol', armor: null, gear: [],
                        alive: true, inHouse: null, indoorPos: null,
                        emoji: 'ü¶π', color: '#2ecc71'
                    },
                    {
                        x: 14, y: 14, hp: 100, maxHp: 100,
                        weapon: 'pistol', armor: null, gear: [],
                        alive: true, inHouse: null, indoorPos: null,
                        emoji: 'üßô', color: '#f39c12'
                    }
                ];
            }
            
            initMap() {
                this.map = [];
                this.houses = [];
                
                // Create 15x15 grid with cleared corners
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const r = Math.random();
                        
                        if (r < 0.08) {
                            this.map[y][x] = { type: 'üå≥', blocks: true, cover: true };
                        } else if (r < 0.14) {
                            this.map[y][x] = { type: 'ü™®', blocks: true, cover: true };
                        } else if (r < 0.16) {
                            this.map[y][x] = { type: 'üè†', blocks: false, house: true };
                            this.houses.push({
                                x: x, y: y,
                                entranceX: x, entranceY: y,
                                indoorMap: this.createIndoorMap(),
                                playersInside: []
                            });
                        } else if (r < 0.20) {
                            this.map[y][x] = { type: 'üì¶', blocks: false, item: true };
                        } else {
                            this.map[y][x] = null;
                        }
                    }
                }
                
                // Clear spawn corners and surrounding area
                const corners = [[0,14], [0,0], [14,0], [14,14]];
                corners.forEach(([x,y]) => {
                    // Clear 2x2 area for each spawn point
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < this.GRID_SIZE && ny >= 0 && ny < this.GRID_SIZE) {
                                this.map[ny][nx] = null;
                            }
                        }
                    }
                });
            }
            
            createIndoorMap() {
                const indoorSize = 8;
                const indoorMap = [];
                
                for (let y = 0; y < indoorSize; y++) {
                    indoorMap[y] = [];
                    for (let x = 0; x < indoorSize; x++) {
                        indoorMap[y][x] = null;
                    }
                }
                
                // Place door
                const doorX = Math.floor(indoorSize / 2) - 1;
                const doorY = indoorSize - 1;
                indoorMap[doorY][doorX] = { type: 'üö™', blocks: false, door: true };
                
                // Walls
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        if (x === 0 || y === 0 || x === indoorSize-1 || y === indoorSize-1) {
                            if (x === doorX && y === doorY) continue;
                            indoorMap[y][x] = { type: 'üß±', blocks: true };
                        }
                    }
                }
                
                // Furniture and items
                const furniture = ['üõãÔ∏è', 'üì∫', 'ü™ë', 'üõèÔ∏è'];
                const foodItems = ['üçé', 'üçó', 'ü•§'];
                
                for (let y = 1; y < indoorSize - 1; y++) {
                    for (let x = 1; x < indoorSize - 1; x++) {
                        if (x >= doorX-1 && x <= doorX+1 && y >= doorY-1) continue;
                        
                        const r = Math.random();
                        if (r < 0.25) {
                            indoorMap[y][x] = { 
                                type: furniture[Math.floor(Math.random()*furniture.length)], 
                                blocks: true 
                            };
                        } else if (r < 0.28) {
                            const food = foodItems[Math.floor(Math.random()*foodItems.length)];
                            indoorMap[y][x] = { 
                                type: food, 
                                blocks: false, 
                                food: true,
                                healAmount: { 'üçé':15, 'üçó':25, 'ü•§':20 }[food]
                            };
                        } else if (r < 0.33) {
                            indoorMap[y][x] = { type: 'üì¶', blocks: false, item: true };
                        }
                    }
                }
                
                return indoorMap;
            }
            
            initWeapons() {
                this.weapons = {
                    pistol: { name: 'Pistol', damage: 20, range: 4, emoji: 'üî´', type: 'linear' },
                    rifle: { name: 'Rifle', damage: 30, range: 8, emoji: 'üéØ', type: 'linear' },
                    shotgun: { name: 'Shotgun', damage: 40, range: 2, emoji: 'üî´', type: 'shotgun' },
                    smg: { name: 'SMG', damage: 15, range: 3, emoji: 'üî´', type: 'rapid' },
                    flamethrower: { name: 'Flamethrower', damage: 25, range: 2, emoji: 'üî•', type: 'flame' },
                    sniper: { name: 'Sniper', damage: 50, range: 12, emoji: 'üéØ', type: 'linear' }
                };
            }
            
            initGear() {
                this.gearTypes = {
                    armor: { name: 'Body Armor', effect: 'damageReduction', value: 0.3, emoji: 'üõ°Ô∏è' },
                    scope: { name: 'Scope', effect: 'rangeBonus', value: 2, emoji: 'üî≠' },
                    medkit: { name: 'Medkit', effect: 'heal', value: 30, emoji: 'üíä' }
                };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.isIndoor && this.currentHouse) {
                    this.drawIndoor();
                } else {
                    this.drawOutdoor();
                }
            }
            
            drawOutdoor() {
                // Draw background
                this.ctx.fillStyle = '#2e7d32';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const tile = this.map[y][x];
                        const screenX = x * this.TILE_SIZE;
                        const screenY = y * this.TILE_SIZE;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#3a7d44';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse) return;
                    this.drawPlayer(player, index, player.x, player.y);
                });
            }
            
            drawIndoor() {
                if (!this.currentHouse) return;
                
                // Draw floor
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const indoorSize = 8;
                const offsetX = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                const offsetY = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                
                // Draw indoor grid
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        const screenX = x * this.TILE_SIZE + offsetX;
                        const screenY = y * this.TILE_SIZE + offsetY;
                        
                        this.ctx.strokeStyle = '#a0522d';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw indoor players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse !== this.currentHouse) return;
                    this.drawPlayer(player, index, player.indoorPos.x, player.indoorPos.y, offsetX, offsetY);
                });
            }
            
            drawPlayer(player, index, gridX, gridY, offsetX = 0, offsetY = 0) {
                const screenX = gridX * this.TILE_SIZE + offsetX;
                const screenY = gridY * this.TILE_SIZE + offsetY;
                
                // Draw player circle
                this.ctx.fillStyle = player.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2,
                    this.TILE_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Pulsing for current player
                if (index === this.currentPlayer) {
                    this.ctx.save();
                    const pulseScale = 1 + 0.1 * Math.sin(Date.now() / 200);
                    this.ctx.translate(screenX + this.TILE_SIZE / 2, screenY + this.TILE_SIZE / 2);
                    this.ctx.scale(pulseScale, pulseScale);
                    this.ctx.translate(-(screenX + this.TILE_SIZE / 2), -(screenY + this.TILE_SIZE / 2));
                    this.ctx.shadowColor = player.color;
                    this.ctx.shadowBlur = 8;
                }
                
                // Player emoji
                this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText(
                    player.emoji,
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2
                );
                
                if (index === this.currentPlayer) {
                    this.ctx.restore();
                }
                
                // Health bar
                const barWidth = this.TILE_SIZE - 4;
                const barHeight = Math.max(3, this.TILE_SIZE * 0.08);
                const barX = screenX + 2;
                const barY = screenY - barHeight - 1;
                
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = player.hp / player.maxHp;
                const healthWidth = healthPercent * barWidth;
                
                this.ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : 
                                   healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
            }
            
            // Game actions
            rollDice() {
                if (this.hasRolled || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (player.inHouse) {
                    this.movesLeft = 99;
                } else {
                    this.movesLeft = Math.floor(Math.random() * 6) + 1 + 
                                    Math.floor(Math.random() * 6) + 1;
                }
                
                this.hasRolled = true;
                this.updateUI();
                this.playSound(500);
                this.stopMove();
                alert(`üé≤ Rolled ${this.movesLeft} movement points!`);
            }
            
            startMove(dx, dy) {
                if (this.aiming) {
                    this.moveAim(dx, dy);
                    return;
                }
                
                this.moveDirection = { dx, dy };
                this.executeMove();
                
                clearInterval(this.moveInterval);
                this.moveInterval = setInterval(() => {
                    this.executeMove();
                }, 200);
            }
            
            stopMove() {
                clearInterval(this.moveInterval);
                this.moveDirection = { dx: 0, dy: 0 };
            }
            
            executeMove() {
                if (!this.gameActive || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const { dx, dy } = this.moveDirection;
                
                if (dx === 0 && dy === 0) return;
                
                if (player.inHouse) {
                    this.movePlayerIndoor(player, dx, dy);
                } else {
                    if (!this.hasRolled || this.movesLeft <= 0) return;
                    this.movePlayerOutdoor(player, dx, dy);
                }
            }
            
            movePlayerOutdoor(player, dx, dy) {
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= this.GRID_SIZE || newY >= this.GRID_SIZE) {
                    return;
                }
                
                const tile = this.map[newY][newX];
                
                if (!tile) {
                    const collision = this.players.some(p => 
                        p.alive && p !== player && !p.inHouse && p.x === newX && p.y === newY);
                    if (collision) return;
                    
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                if (tile.blocks) return;
                
                if (tile.house) {
                    this.enterHouse(player, newX, newY);
                    return;
                }
                
                if (tile.item) {
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.pickupItem(player, newX, newY);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            movePlayerIndoor(player, dx, dy) {
                if (!player.indoorPos) return;
                
                const newX = player.indoorPos.x + dx;
                const newY = player.indoorPos.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= 8 || newY >= 8) return;
                
                const tile = player.inHouse.indoorMap[newY][newX];
                
                if (!tile) {
                    const collision = this.players.find(p => 
                        p.alive && p !== player && 
                        p.inHouse === player.inHouse &&
                        p.indoorPos && p.indoorPos.x === newX && p.indoorPos.y === newY);
                    
                    if (collision) return;
                    
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                if (tile.blocks) return;
                
                if (tile.door) {
                    this.exitHouse(player);
                    return;
                }
                
                if (tile.food) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    player.hp = Math.min(player.maxHp, player.hp + tile.healAmount);
                    player.inHouse.indoorMap[newY][newX] = null;
                    this.updateUI();
                    this.draw();
                    this.playSound(700);
                    this.stopMove();
                    alert(`üçó Healed ${tile.healAmount} HP!`);
                    return;
                }
                
                if (tile.item) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.pickupItem(player, newX, newY, true);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            enterHouse(player, houseX, houseY) {
                // Find the house at this position
                const house = this.houses.find(h => h.x === houseX && h.y === houseY);
                if (!house) return;
                
                // Find the door position in the indoor map
                let doorX = null, doorY = null;
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const tile = house.indoorMap[y][x];
                        if (tile && tile.door) {
                            doorX = x;
                            doorY = y;
                            break;
                        }
                    }
                    if (doorX !== null) break;
                }
                
                if (doorX === null || doorY === null) return;
                
                // Set player as inside the house
                player.inHouse = house;
                player.indoorPos = { x: doorX, y: doorY };
                
                // Add player to house's player list
                const playerIndex = this.players.indexOf(player);
                if (!house.playersInside.includes(playerIndex)) {
                    house.playersInside.push(playerIndex);
                }
                
                // Update view if this is the current player
                if (this.players[this.currentPlayer] === player) {
                    this.currentHouse = house;
                    this.isIndoor = true;
                }
                
                this.updateUI();
                this.draw();
                this.playSound(400);
            }
            
            exitHouse(player) {
                if (!player.inHouse) return;
                
                const house = player.inHouse;
                const houseX = house.x;
                const houseY = house.y;
                
                // Remove player from house's player list
                const playerIndex = this.players.indexOf(player);
                const housePlayerIndex = house.playersInside.indexOf(playerIndex);
                if (housePlayerIndex > -1) {
                    house.playersInside.splice(housePlayerIndex, 1);
                }
                
                // Place player back at house entrance
                player.x = houseX;
                player.y = houseY;
                player.inHouse = null;
                player.indoorPos = null;
                
                // Update view if this is the current player
                if (this.players[this.currentPlayer] === player) {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
                
                this.updateUI();
                this.draw();
                this.playSound(400);
            }
            
            enterAim() {
                if (this.hasShot || this.aiming) return;
                if (!this.hasRolled && !this.players[this.currentPlayer].inHouse) {
                    alert("You need to roll dice first!");
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                
                if (this.isIndoor && player.indoorPos) {
                    this.aim = {
                        x: player.indoorPos.x,
                        y: player.indoorPos.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                } else {
                    this.aim = {
                        x: player.x,
                        y: player.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                }
                
                this.aiming = true;
                this.updateAimCursor();
                this.updateUI();
                
                this.statusIndicator.textContent = "üéØ AIMING MODE - Use movement buttons to aim";
                this.statusIndicator.className = "status-indicator status-aiming";
                this.statusIndicator.style.display = 'block';
            }
            
            moveAim(dx, dy) {
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                if (this.aim.dx === null && this.aim.dy === null) {
                    this.aim.dx = dx;
                    this.aim.dy = dy;
                }
                
                if (dx !== this.aim.dx || dy !== this.aim.dy) return;
                if (this.aim.steps >= range) return;
                
                const newX = this.aim.x + dx;
                const newY = this.aim.y + dy;
                
                const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                if (newX < 0 || newY < 0 || newX >= maxBound || newY >= maxBound) return;
                
                if (this.isIndoor) {
                    const tile = this.currentHouse.indoorMap[newY][newX];
                    if (tile && tile.blocks) return;
                } else {
                    const tile = this.map[newY][newX];
                    if (tile && tile.blocks) return;
                }
                
                this.aim.x = newX;
                this.aim.y = newY;
                this.aim.steps++;
                
                this.updateAimCursor();
                this.playSound(400);
            }
            
            updateAimCursor() {
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                if (!this.aiming) return;
                
                let screenX, screenY;
                
                if (this.isIndoor) {
                    const offsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const offsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    screenX = this.aim.x * this.TILE_SIZE + offsetX;
                    screenY = this.aim.y * this.TILE_SIZE + offsetY;
                } else {
                    screenX = this.aim.x * this.TILE_SIZE;
                    screenY = this.aim.y * this.TILE_SIZE;
                }
                
                const cursor = document.createElement('div');
                cursor.className = 'aim-cell';
                cursor.style.left = screenX + 'px';
                cursor.style.top = screenY + 'px';
                cursor.style.width = this.TILE_SIZE + 'px';
                cursor.style.height = this.TILE_SIZE + 'px';
                
                this.aimOverlay.appendChild(cursor);
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                if (weapon.type === 'shotgun' && this.aim.dx !== null) {
                    const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                    
                    patterns.forEach(([dx, dy]) => {
                        const x = this.aim.x + dx;
                        const y = this.aim.y + dy;
                        
                        const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                        if (x < 0 || y < 0 || x >= maxBound || y >= maxBound) return;
                        
                        if (this.isIndoor) {
                            const tile = this.currentHouse.indoorMap[y][x];
                            if (tile && tile.blocks) return;
                        } else {
                            const tile = this.map[y][x];
                            if (tile && tile.blocks) return;
                        }
                        
                        let cellX, cellY;
                        if (this.isIndoor) {
                            const offset = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                            cellX = x * this.TILE_SIZE + offset;
                            cellY = y * this.TILE_SIZE + offset;
                        } else {
                            cellX = x * this.TILE_SIZE;
                            cellY = y * this.TILE_SIZE;
                        }
                        
                        const cell = document.createElement('div');
                        cell.className = 'shotgun-cell';
                        cell.style.left = cellX + 'px';
                        cell.style.top = cellY + 'px';
                        cell.style.width = this.TILE_SIZE + 'px';
                        cell.style.height = this.TILE_SIZE + 'px';
                        
                        this.shotgunPreview.appendChild(cell);
                    });
                }
            }
            
            getShotgunPattern(dx, dy) {
                if (dx !== 0 && dy === 0) {
                    return [[dx,0], [dx,-1], [dx,1]];
                }
                if (dy !== 0 && dx === 0) {
                    return [[0,dy], [-1,dy], [1,dy]];
                }
                return [[dx, dy]];
            }
            
            shoot() {
                if (!this.aiming || this.hasShot) return;
                
                const shooter = this.players[this.currentPlayer];
                const weapon = this.weapons[shooter.weapon];
                
                switch (weapon.type) {
                    case 'linear':
                        this.fireLinear(shooter, weapon);
                        break;
                    case 'shotgun':
                        this.fireShotgun(shooter, weapon);
                        break;
                    case 'rapid':
                        this.fireRapid(shooter, weapon);
                        break;
                    case 'flame':
                        this.fireFlamethrower(shooter, weapon);
                        break;
                }
                
                this.hasShot = true;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                this.statusIndicator.style.display = 'none';
                
                this.updateUI();
                this.draw();
            }
            
            fireLinear(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target at aimed position!");
                    return;
                }
                
                if (!this.checkLineOfSight(shooter, target)) {
                    alert('Shot blocked by cover!');
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
            }
            
            fireShotgun(shooter, weapon) {
                if (this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                let hitCount = 0;
                
                patterns.forEach(([dx, dy]) => {
                    const targetX = this.aim.x + dx;
                    const targetY = this.aim.y + dy;
                    
                    const target = this.findTargetAt(shooter, targetX, targetY);
                    if (!target) return;
                    if (!this.checkLineOfSight(shooter, target)) return;
                    
                    const pelletDamage = Math.floor(weapon.damage / 2);
                    this.applyDamage(shooter, target, pelletDamage);
                    hitCount++;
                });
                
                if (hitCount > 0) {
                    this.playSound(300, 0.2);
                } else {
                    this.playSound(200, 0.1);
                    alert("Shotgun spread missed!");
                }
            }
            
            fireRapid(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target || !this.checkLineOfSight(shooter, target)) {
                    this.playSound(200, 0.1);
                    alert("No valid target!");
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                
                setTimeout(() => {
                    if (target.alive) {
                        this.applyDamage(shooter, target, weapon.damage);
                    }
                }, 200);
                
                this.playSound(400, 0.3);
            }
            
            fireFlamethrower(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target in range!");
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                this.playSound(200, 0.4);
            }
            
            findTargetAt(shooter, targetX, targetY) {
                if (this.isIndoor) {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        p.inHouse === shooter.inHouse &&
                        p.indoorPos && p.indoorPos.x === targetX && p.indoorPos.y === targetY
                    );
                } else {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        !p.inHouse && p.x === targetX && p.y === targetY
                    );
                }
            }
            
            checkLineOfSight(shooter, target) {
                const weapon = this.weapons[shooter.weapon];
                if (weapon.type === 'flame') return true;
                
                let x1, y1, x2, y2, map;
                
                if (this.isIndoor) {
                    x1 = shooter.indoorPos.x;
                    y1 = shooter.indoorPos.y;
                    x2 = target.indoorPos.x;
                    y2 = target.indoorPos.y;
                    map = this.currentHouse.indoorMap;
                } else {
                    x1 = shooter.x;
                    y1 = shooter.y;
                    x2 = target.x;
                    y2 = target.y;
                    map = this.map;
                }
                
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                let x = x1;
                let y = y1;
                
                while (true) {
                    if (x !== x1 || y !== y1) {
                        if (map[y] && map[y][x] && map[y][x].blocks) {
                            return false;
                        }
                    }
                    
                    if (x === x2 && y === y2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return true;
            }
            
            applyDamage(shooter, target, baseDamage) {
                let finalDamage = baseDamage;
                
                if (target.armor && target.armor.effect === 'damageReduction') {
                    finalDamage = Math.floor(baseDamage * (1 - target.armor.value));
                }
                
                target.hp -= finalDamage;
                
                this.playSound(400 + finalDamage * 2);
                
                if (target.hp <= 0) {
                    target.alive = false;
                    target.hp = 0;
                    
                    if (target.inHouse) {
                        const house = target.inHouse;
                        const playerIndex = this.players.indexOf(target);
                        const houseIndex = house.playersInside.indexOf(playerIndex);
                        if (houseIndex > -1) {
                            house.playersInside.splice(houseIndex, 1);
                        }
                        target.inHouse = null;
                        target.indoorPos = null;
                    }
                    
                    const shooterIndex = this.players.indexOf(shooter);
                    const targetIndex = this.players.indexOf(target);
                    
                    alert(`üéØ Player ${shooterIndex + 1} eliminated Player ${targetIndex + 1}!`);
                    
                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        const winnerIndex = this.players.findIndex(p => p.alive);
                        alert(`üéâ üèÜ Player ${winnerIndex + 1} wins the game! üèÜ üéâ`);
                        this.gameActive = false;
                    }
                }
                
                this.updateUI();
            }
            
            pickupItem(player, x, y, indoor = false) {
                // Stop any ongoing movement to prevent involuntary movement after alert
                this.stopMove();
                
                const weapons = ['pistol', 'rifle', 'shotgun', 'smg', 'flamethrower', 'sniper'];
                const gearTypes = ['armor', 'scope', 'medkit'];
                
                const isWeapon = Math.random() > 0.5;
                
                if (isWeapon) {
                    const newWeapon = weapons[Math.floor(Math.random() * weapons.length)];
                    const oldWeapon = player.weapon;
                    player.weapon = newWeapon;
                    
                    alert(`üî´ Found ${this.weapons[newWeapon].name}!\nReplaced your ${this.weapons[oldWeapon].name}`);
                } else {
                    const gearType = gearTypes[Math.floor(Math.random() * gearTypes.length)];
                    const gear = { ...this.gearTypes[gearType] };
                    
                    if (gearType === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + gear.value);
                        alert(`üíä Found Medkit!\nHealed ${gear.value} HP.`);
                    } else if (gearType === 'armor') {
                        player.armor = gear;
                        alert(`üõ°Ô∏è Found Body Armor!\nNow reduces damage by 30%`);
                    } else {
                        player.gear.push(gear);
                        alert(`üî≠ Found Scope!\n+${gear.value} to weapon range`);
                    }
                }
                
                if (indoor) {
                    player.inHouse.indoorMap[y][x] = null;
                } else {
                    this.map[y][x] = null;
                }
                
                this.updateUI();
            }
            
            endTurn() {
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                this.statusIndicator.style.display = 'none';
                
                let attempts = 0;
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % 4;
                    attempts++;
                    if (attempts > 4) break;
                } while (!this.players[this.currentPlayer].alive);
                
                this.updateViewForCurrentPlayer();
                this.updateUI();
                this.draw();
                
                this.stopMove();
                alert(`‚Ü™Ô∏è Turn passed to Player ${this.currentPlayer + 1}`);
            }
            
            updateViewForCurrentPlayer() {
                const currentPlayer = this.players[this.currentPlayer];
                
                if (currentPlayer.inHouse) {
                    this.currentHouse = currentPlayer.inHouse;
                    this.isIndoor = true;
                } else {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
            }
            
            updateUI() {
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                // Update mini info
                this.miniPlayer.textContent = `P${this.currentPlayer + 1} ${player.emoji}`;
                
                if (this.aiming) {
                    this.miniMoves.textContent = "Aiming...";
                } else if (player.inHouse) {
                    this.miniMoves.textContent = "Indoors ‚àû";
                } else if (this.hasRolled) {
                    this.miniMoves.textContent = `${this.movesLeft} moves`;
                } else {
                    this.miniMoves.textContent = "Roll dice!";
                }
                
                // Update weapon info
                this.miniWeapon.textContent = weapon.name;
                
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                this.miniRange.textContent = `Range: ${range}`;
                this.miniDamage.textContent = `Dmg: ${weapon.damage}`;
                
                // Update player info panel
                this.updatePlayerInfoPanel();
                
                // Update button states
                const rollBtn = document.querySelector('.action-btn.roll');
                const aimBtn = document.querySelector('.action-btn.aim');
                const shootBtn = document.querySelector('.action-btn.shoot');
                const endBtn = document.querySelector('.action-btn.end');
                
                rollBtn.disabled = this.hasRolled || this.aiming || player.inHouse;
                aimBtn.disabled = this.hasShot || this.aiming || (!this.hasRolled && !player.inHouse);
                shootBtn.disabled = !this.aiming;
                endBtn.disabled = false;
                
                [rollBtn, aimBtn, shootBtn, endBtn].forEach(btn => {
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                });
            }
            
            updatePlayerInfoPanel() {
                const playersInfo = document.getElementById('players-info');
                playersInfo.innerHTML = '';
                
                this.players.forEach((player, index) => {
                    if (!player.alive) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'player-info';
                        playerDiv.innerHTML = `
                            <div class="player-header">
                                <span class="player-emoji">üíÄ</span>
                                <span class="player-name">Player ${index + 1} (Eliminated)</span>
                            </div>
                        `;
                        playersInfo.appendChild(playerDiv);
                        return;
                    }
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player-info ${index === this.currentPlayer ? 'current' : ''}`;
                    
                    const weapon = this.weapons[player.weapon];
                    const armorEmoji = player.armor ? player.armor.emoji : '';
                    const gearList = player.gear.map(g => g.emoji).join(' ');
                    
                    let range = weapon.range;
                    player.gear.forEach(g => {
                        if (g.effect === 'rangeBonus') range += g.value;
                    });
                    
                    playerDiv.innerHTML = `
                        <div class="player-header">
                            <span class="player-emoji">${player.emoji}</span>
                            <span class="player-name">Player ${index + 1}</span>
                            ${player.inHouse ? '<span style="color:#9b59b6;">üè†</span>' : ''}
                            ${index === this.currentPlayer ? '<span style="color:#3498db;">‚ñ∂Ô∏è</span>' : ''}
                        </div>
                        <div class="player-hp">
                            <div class="player-hp-bar" style="width: ${(player.hp/player.maxHp)*100}%"></div>
                        </div>
                        <div class="player-stats">
                            <div class="stat-item">
                                <span class="stat-label">Weapon:</span>
                                <span>${weapon.emoji} ${weapon.name}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range:</span>
                                <span>${range} tiles</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Damage:</span>
                                <span>${weapon.damage}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Armor:</span>
                                <span>${armorEmoji || 'None'}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Gear:</span>
                                <span>${gearList || 'None'}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Moves:</span>
                                <span>${player.inHouse ? '‚àû' : (index === this.currentPlayer && this.hasRolled ? this.movesLeft : '-')}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Health:</span>
                                <span>${player.hp}/${player.maxHp}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Location:</span>
                                <span>${player.inHouse ? 'Indoors' : 'Outdoors'}</span>
                            </div>
                        </div>
                    `;
                    
                    playersInfo.appendChild(playerDiv);
                });
            }
            
            playSound(frequency, duration = 0.1, type = 'sine') {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Sound effect');
                }
            }
        }

        // Initialize game
        function initGame() {
            game = new MobileBattleRoyale();
            
            // Handle resize events
            window.addEventListener('resize', () => {
                checkOrientation();
                if (game) game.handleResize();
            });
            
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    checkOrientation();
                    if (game) game.handleResize();
                }, 100);
            });
            
            // Fullscreen change events
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function handleFullscreenChange() {
            // Force resize after fullscreen change
            setTimeout(() => {
                if (game) game.handleResize();
            }, 100);
        }

        // Global functions
        function startMove(dx, dy) {
            if (game) game.startMove(dx, dy);
        }

        function stopMove() {
            if (game) game.stopMove();
        }

        function rollDice() {
            if (game) game.rollDice();
        }

        function enterAim() {
            if (game) game.enterAim();
        }

        function shoot() {
            if (game) game.shoot();
        }

        function endTurn() {
            if (game) game.endTurn();
        }

        function showPlayerInfo() {
            document.getElementById('player-info-panel').classList.add('active');
        }

        function hidePlayerInfo() {
            document.getElementById('player-info-panel').classList.remove('active');
        }

        function showRules() {
            document.getElementById('rules-panel').classList.add('active');
        }

        function hideRules() {
            document.getElementById('rules-panel').classList.remove('active');
        }

        function resetGame() {
            if (confirm('üîÑ Reset the game? All progress will be lost.')) {
                location.reload();
            }
        }

        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Check if already in fullscreen or landscape
        window.addEventListener('load', () => {
            // Check if already fullscreen or on non-mobile
            const isFullscreen = document.fullscreenElement || 
                                document.webkitFullscreenElement || 
                                document.mozFullScreenElement || 
                                document.msFullscreenElement;
            
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (!isMobile || isFullscreen) {
                // Skip fullscreen overlay for non-mobile or already fullscreen
                document.getElementById('fullscreen-overlay').style.display = 'none';
                checkOrientation();
                initGame();
            }
        });
    </script>
</body>
</html>
