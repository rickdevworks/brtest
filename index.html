<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        /* Landscape warning - unskippable */
        #landscape-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            text-align: center;
        }

        #landscape-warning h1 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #landscape-warning p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #landscape-warning .rotate-icon {
            font-size: 60px;
            margin: 20px 0;
            animation: rotate 2s infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
        }

        /* Main game layout - optimized for small screens */
        #game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Compact game layout */
        .game-layout {
            display: flex;
            height: 100%;
            width: 100%;
            gap: 2px;
            padding: 2px;
            background: #2d3436;
        }

        /* Left side - compact actions */
        #left-controls {
            width: 80px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            gap: 8px;
        }

        /* Top mini info bar */
        .mini-info {
            width: 100%;
            background: rgba(45, 52, 54, 0.95);
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            font-size: 12px;
            line-height: 1.3;
            border: 1px solid #34495e;
            margin-bottom: 5px;
        }

        .current-player {
            color: #3498db;
            font-weight: bold;
            font-size: 14px;
        }

        .moves-info {
            color: #f39c12;
            margin-top: 2px;
        }

        /* Action buttons - compact */
        .action-btn {
            width: 70px;
            height: 40px;
            background: #3498db;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            padding: 2px;
            text-align: center;
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .action-btn .icon {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .action-btn.roll { background: #f39c12; }
        .action-btn.aim { background: #e74c3c; }
        .action-btn.shoot { background: #c0392b; }
        .action-btn.end { background: #7f8c8d; }
        .action-btn.info { 
            background: #9b59b6;
            height: 35px;
            margin-top: auto;
        }
        .action-btn.rules { 
            background: #1abc9c;
            height: 35px;
        }

        /* Center game area - maximizes grid space */
        #center-game {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            max-height: 100vh;
            overflow: hidden;
        }

        /* Canvas container - fills center with safe margins */
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: #2d3436;
            padding: 5px;
        }

        canvas {
            display: block;
            background: #2d3436;
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
            /* Ensure canvas doesn't exceed container */
            box-sizing: content-box;
        }

        /* Right side - movement controls */
        #right-controls {
            width: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
            gap: 10px;
        }

        /* Movement D-pad */
        #movement-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 8px;
            background: rgba(45, 52, 54, 0.95);
            padding: 10px;
            border-radius: 20px;
            border: 1px solid #34495e;
        }

        .movement-btn {
            width: 50px;
            height: 50px;
            background: #34495e;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .movement-btn:active {
            background: #2c3e50;
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .movement-btn.up { grid-area: up; }
        .movement-btn.left { grid-area: left; }
        .movement-btn.right { grid-area: right; }
        .movement-btn.down { grid-area: down; }

        /* Weapon info on right side */
        .weapon-info {
            width: 100%;
            background: rgba(45, 52, 54, 0.95);
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            font-size: 12px;
            border: 1px solid #34495e;
            margin-top: 5px;
        }

        .weapon-name {
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 3px;
        }

        /* Panels overlay */
        .panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        .panel.active {
            display: flex;
        }

        .panel-content {
            background: rgba(45, 52, 54, 0.95);
            margin: 15px;
            border-radius: 15px;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-height: calc(100vh - 30px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #34495e;
        }

        .panel-header h2 {
            color: #3498db;
            font-size: 18px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 22px;
            cursor: pointer;
            padding: 5px;
        }

        .players-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .player-info {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .player-info.current {
            border-left: 4px solid #3498db;
            background: rgba(52, 73, 94, 0.8);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .player-emoji {
            font-size: 20px;
        }

        .player-name {
            font-weight: 600;
            font-size: 15px;
        }

        .player-hp {
            width: 100%;
            height: 6px;
            background: #2c3e50;
            border-radius: 3px;
            overflow: hidden;
            margin: 6px 0;
        }

        .player-hp-bar {
            height: 100%;
            background: #2ecc71;
            border-radius: 3px;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
            color: #95a5a6;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            color: #ecf0f1;
        }

        .gear-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }

        .gear-item {
            font-size: 14px;
        }

        /* Rules panel */
        .rules-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .rule-section {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .rule-section h3 {
            color: #3498db;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .rule-section ul {
            padding-left: 20px;
            color: #ecf0f1;
            font-size: 12px;
            line-height: 1.4;
        }

        .rule-section li {
            margin-bottom: 5px;
        }

        /* Aim overlay */
        #aim-overlay, #shotgun-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .aim-cell {
            position: absolute;
            background: rgba(255, 255, 0, 0.3);
            border: 2px solid yellow;
            border-radius: 3px;
            animation: pulse-aim 0.8s infinite;
        }

        @keyframes pulse-aim {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .shotgun-cell {
            position: absolute;
            background: rgba(255, 165, 0, 0.3);
            border: 2px solid orange;
            border-radius: 3px;
        }

        /* Status indicators */
        .status-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            z-index: 60;
            backdrop-filter: blur(5px);
            border: 1px solid;
            max-width: 90%;
            text-align: center;
        }

        .status-aiming {
            border-color: yellow;
            color: yellow;
            animation: pulse-status 1s infinite;
        }

        @keyframes pulse-status {
            0%, 100% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
        }

        /* Mobile optimization */
        @media (max-height: 600px) {
            #left-controls { width: 70px; }
            #right-controls { width: 85px; }
            
            .action-btn {
                width: 60px;
                height: 35px;
                font-size: 10px;
            }
            
            .action-btn .icon {
                font-size: 14px;
            }
            
            .movement-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            .mini-info, .weapon-info {
                font-size: 10px;
                padding: 6px;
            }
            
            .current-player {
                font-size: 12px;
            }
        }

        @media (max-width: 700px) {
            .game-layout {
                gap: 1px;
                padding: 1px;
            }
            
            #left-controls { width: 65px; }
            #right-controls { width: 75px; }
            
            .action-btn {
                width: 55px;
                height: 32px;
                font-size: 9px;
            }
            
            .movement-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        @media (orientation: portrait) {
            #game-container {
                display: none !important;
            }
            #landscape-warning {
                display: flex !important;
            }
        }

        /* Ensure no scrolling */
        body, html, #game-container, .game-layout, #center-game, #canvas-container {
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- Landscape warning -->
    <div id="landscape-warning">
        <h1>üîÑ Please Rotate Your Device</h1>
        <div class="rotate-icon">üì±</div>
        <p>This game is optimized for landscape mode.<br>Please rotate your device to play.</p>
        <p><small>If rotation doesn't work, check your device's orientation lock.</small></p>
    </div>

    <!-- Main game container -->
    <div id="game-container">
        <!-- Status indicator for aiming mode -->
        <div id="status-indicator" class="status-indicator" style="display: none;"></div>
        
        <div class="game-layout">
            <!-- Left side: Action buttons and mini info -->
            <div id="left-controls">
                <!-- Mini player info at top -->
                <div class="mini-info">
                    <div class="current-player" id="mini-player">P1</div>
                    <div class="moves-info" id="mini-moves">Roll dice!</div>
                </div>
                
                <!-- Action buttons -->
                <button class="action-btn roll" onclick="rollDice()">
                    <span class="icon">üé≤</span>
                    <span>Roll Dice</span>
                </button>
                <button class="action-btn aim" onclick="enterAim()">
                    <span class="icon">üéØ</span>
                    <span>Aim</span>
                </button>
                <button class="action-btn shoot" onclick="shoot()">
                    <span class="icon">üî´</span>
                    <span>Shoot</span>
                </button>
                <button class="action-btn end" onclick="endTurn()">
                    <span class="icon">‚è≠Ô∏è</span>
                    <span>End Turn</span>
                </button>
                
                <!-- Extra buttons at bottom -->
                <button class="action-btn info" onclick="showPlayerInfo()">
                    <span class="icon">üë§</span>
                    <span>Players</span>
                </button>
                <button class="action-btn rules" onclick="showRules()">
                    <span class="icon">üìñ</span>
                    <span>Rules</span>
                </button>
            </div>

            <!-- Center: Game area -->
            <div id="center-game">
                <!-- Canvas container -->
                <div id="canvas-container">
                    <canvas id="gameCanvas"></canvas>
                    <div id="aim-overlay"></div>
                    <div id="shotgun-preview"></div>
                </div>
            </div>

            <!-- Right side: Movement controls and weapon info -->
            <div id="right-controls">
                <!-- Movement D-pad -->
                <div id="movement-controls">
                    <button class="movement-btn up" onpointerdown="startMove(0, -1)" onpointerup="stopMove()">‚Üë</button>
                    <button class="movement-btn left" onpointerdown="startMove(-1, 0)" onpointerup="stopMove()">‚Üê</button>
                    <button class="movement-btn right" onpointerdown="startMove(1, 0)" onpointerup="stopMove()">‚Üí</button>
                    <button class="movement-btn down" onpointerdown="startMove(0, 1)" onpointerup="stopMove()">‚Üì</button>
                </div>
                
                <!-- Weapon info -->
                <div class="weapon-info">
                    <div class="weapon-name" id="mini-weapon">Pistol</div>
                    <div id="mini-range">Range: 4</div>
                    <div id="mini-damage">Dmg: 20</div>
                </div>
            </div>
        </div>

        <!-- Player Info Panel -->
        <div id="player-info-panel" class="panel">
            <div class="panel-content">
                <div class="panel-header">
                    <h2>üë• Player Information</h2>
                    <button class="close-btn" onclick="hidePlayerInfo()">‚úï</button>
                </div>
                <div class="players-list" id="players-info">
                    <!-- Player info will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Rules Panel -->
        <div id="rules-panel" class="panel">
            <div class="panel-content">
                <div class="panel-header">
                    <h2>üìñ Game Rules</h2>
                    <button class="close-btn" onclick="hideRules()">‚úï</button>
                </div>
                <div class="rules-list">
                    <div class="rule-section">
                        <h3>üéØ How to Play</h3>
                        <ul>
                            <li><strong>Roll Dice</strong> to get movement points (2-12)</li>
                            <li><strong>Move</strong> your character with the D-pad</li>
                            <li><strong>Aim</strong> at opponents (starts from your position)</li>
                            <li><strong>Shoot</strong> when ready to attack</li>
                            <li><strong>End Turn</strong> when done</li>
                        </ul>
                    </div>
                    
                    <div class="rule-section">
                        <h3>üè† Houses & Items</h3>
                        <ul>
                            <li>Enter <strong>Houses</strong> for loot and cover</li>
                            <li>Inside houses: <strong>Infinite movement</strong></li>
                            <li>Find <strong>Weapons</strong> in crates üì¶</li>
                            <li>Collect <strong>Armor</strong> üõ°Ô∏è for damage reduction</li>
                            <li>Heal with <strong>Food</strong> üçóüçéü•§</li>
                        </ul>
                    </div>
                    
                    <div class="rule-section">
                        <h3>üî´ Weapons</h3>
                        <ul>
                            <li><strong>Pistol</strong>: Balanced (20 dmg, 4 range)</li>
                            <li><strong>Shotgun</strong>: Spread (40 dmg, 2 range)</li>
                            <li><strong>Rifle</strong>: Long range (30 dmg, 8 range)</li>
                            <li><strong>SMG</strong>: Rapid fire (15√ó2 dmg, 3 range)</li>
                            <li><strong>Flamethrower</strong>: Ignores cover (25 dmg, 2 range)</li>
                            <li><strong>Sniper</strong>: High damage (50 dmg, 12 range)</li>
                        </ul>
                    </div>
                    
                    <div class="rule-section">
                        <h3>üéÆ Combat</h3>
                        <ul>
                            <li>Line of sight required (except flamethrower)</li>
                            <li>Trees üå≥ and Rocks ü™® block shots</li>
                            <li>Walls üß± block movement and shots</li>
                            <li>Armor reduces damage by 30%</li>
                            <li>Scope üî≠ increases weapon range</li>
                        </ul>
                    </div>
                    
                    <div class="rule-section">
                        <h3>üèÜ Winning</h3>
                        <ul>
                            <li>Last player standing wins</li>
                            <li>Eliminate all opponents</li>
                            <li>Watch your health ‚ù§Ô∏è</li>
                            <li>Use cover strategically</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mobile Battle Royale Game - Final Optimized Version
        class MobileBattleRoyale {
            constructor() {
                // Core grid constants
                this.GRID_SIZE = 15;
                this.INDOOR_SIZE = 8;
                this.TILE_SIZE = 0; // Dynamic based on screen
                this.CANVAS_SIZE = 0; // Dynamic
                
                // Game elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.aimOverlay = document.getElementById('aim-overlay');
                this.shotgunPreview = document.getElementById('shotgun-preview');
                this.statusIndicator = document.getElementById('status-indicator');
                this.canvasContainer = document.getElementById('canvas-container');
                
                // Mini info elements
                this.miniPlayer = document.getElementById('mini-player');
                this.miniMoves = document.getElementById('mini-moves');
                this.miniWeapon = document.getElementById('mini-weapon');
                this.miniRange = document.getElementById('mini-range');
                this.miniDamage = document.getElementById('mini-damage');
                
                // Game state
                this.gameActive = true;
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasRolled = false;
                this.hasShot = false;
                this.aiming = false;
                this.isIndoor = false;
                this.currentHouse = null;
                
                // Movement interval
                this.moveInterval = null;
                this.moveDirection = { dx: 0, dy: 0 };
                
                // Aim state
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                
                // Initialize game
                this.initPlayers();
                this.initMap();
                this.initWeapons();
                this.initGear();
                
                // Setup canvas and handle resize
                this.setupCanvas();
                window.addEventListener('resize', () => this.handleResize());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.checkOrientation();
                        this.handleResize();
                    }, 100);
                });
                
                this.handleResize();
                this.checkOrientation();
                this.updateUI();
                this.draw();
            }
            
            setupCanvas() {
                // Get container dimensions with safe margins
                const container = this.canvasContainer;
                const containerWidth = container.clientWidth - 10; // 5px padding each side
                const containerHeight = container.clientHeight - 10;
                
                // Calculate tile size to fit entire grid
                const maxTileSizeByWidth = Math.floor(containerWidth / this.GRID_SIZE);
                const maxTileSizeByHeight = Math.floor(containerHeight / this.GRID_SIZE);
                this.TILE_SIZE = Math.min(maxTileSizeByWidth, maxTileSizeByHeight);
                
                // Ensure tile size is at least 25px for visibility
                this.TILE_SIZE = Math.max(this.TILE_SIZE, 25);
                
                // Calculate canvas size with safe margin
                this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                
                // Set canvas dimensions
                this.canvas.width = this.CANVAS_SIZE;
                this.canvas.height = this.CANVAS_SIZE;
                
                // Setup context
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            handleResize() {
                // Update canvas size
                this.setupCanvas();
                
                // Center canvas in container with safe margins
                const container = this.canvasContainer;
                const marginLeft = Math.max(0, (container.clientWidth - this.CANVAS_SIZE) / 2);
                const marginTop = Math.max(0, (container.clientHeight - this.CANVAS_SIZE) / 2);
                
                this.canvas.style.marginLeft = `${marginLeft}px`;
                this.canvas.style.marginTop = `${marginTop}px`;
                
                // Update aim overlay to match
                this.aimOverlay.style.width = `${this.CANVAS_SIZE}px`;
                this.aimOverlay.style.height = `${this.CANVAS_SIZE}px`;
                this.aimOverlay.style.marginLeft = `${marginLeft}px`;
                this.aimOverlay.style.marginTop = `${marginTop}px`;
                
                this.shotgunPreview.style.width = `${this.CANVAS_SIZE}px`;
                this.shotgunPreview.style.height = `${this.CANVAS_SIZE}px`;
                this.shotgunPreview.style.marginLeft = `${marginLeft}px`;
                this.shotgunPreview.style.marginTop = `${marginTop}px`;
                
                // Redraw
                if (this.gameActive) {
                    this.draw();
                    if (this.aiming) {
                        this.updateAimCursor();
                    }
                }
            }
            
            checkOrientation() {
                const warning = document.getElementById('landscape-warning');
                const gameContainer = document.getElementById('game-container');
                
                // Check if device is in landscape
                const isLandscape = window.innerWidth > window.innerHeight;
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isLandscape || !isMobile) {
                    warning.style.display = 'none';
                    gameContainer.style.display = 'block';
                } else {
                    warning.style.display = 'flex';
                    gameContainer.style.display = 'none';
                }
            }
            
            initPlayers() {
                this.players = [
                    {
                        x: 0, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üòé',
                        color: '#3498db'
                    },
                    {
                        x: 0, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü§†',
                        color: '#e74c3c'
                    },
                    {
                        x: 14, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü¶π',
                        color: '#2ecc71'
                    },
                    {
                        x: 14, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üßô',
                        color: '#f39c12'
                    }
                ];
            }
            
            initMap() {
                this.map = [];
                this.houses = [];
                
                // Create 15x15 grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const r = Math.random();
                        
                        if (r < 0.08) {
                            this.map[y][x] = { type: 'üå≥', blocks: true, cover: true };
                        } else if (r < 0.14) {
                            this.map[y][x] = { type: 'ü™®', blocks: true, cover: true };
                        } else if (r < 0.16) {
                            this.map[y][x] = { type: 'üè†', blocks: false, house: true };
                            this.houses.push({
                                x: x, y: y,
                                entranceX: x, entranceY: y,
                                indoorMap: this.createIndoorMap(),
                                playersInside: []
                            });
                        } else if (r < 0.20) {
                            this.map[y][x] = { type: 'üì¶', blocks: false, item: true };
                        } else {
                            this.map[y][x] = null;
                        }
                    }
                }
                
                // Clear corners for spawn points (with extra space around)
                const corners = [[0,14], [0,0], [14,0], [14,14]];
                corners.forEach(([x,y]) => {
                    this.map[y][x] = null;
                    // Clear one tile around corners for better visibility
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < this.GRID_SIZE && ny >= 0 && ny < this.GRID_SIZE) {
                                if (this.map[ny][nx] && this.map[ny][nx].blocks) {
                                    this.map[ny][nx] = null;
                                }
                            }
                        }
                    }
                });
            }
            
            createIndoorMap() {
                const indoorSize = 8;
                const indoorMap = [];
                
                for (let y = 0; y < indoorSize; y++) {
                    indoorMap[y] = [];
                    for (let x = 0; x < indoorSize; x++) {
                        indoorMap[y][x] = null;
                    }
                }
                
                // Place door
                const doorX = Math.floor(indoorSize / 2) - 1;
                const doorY = indoorSize - 1;
                indoorMap[doorY][doorX] = { type: 'üö™', blocks: false, door: true };
                
                // Walls
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        if (x === 0 || y === 0 || x === indoorSize-1 || y === indoorSize-1) {
                            if (x === doorX && y === doorY) continue;
                            indoorMap[y][x] = { type: 'üß±', blocks: true };
                        }
                    }
                }
                
                // Furniture and items
                const furniture = ['üõãÔ∏è', 'üì∫', 'ü™ë', 'üõèÔ∏è'];
                const foodItems = ['üçé', 'üçó', 'ü•§'];
                
                for (let y = 1; y < indoorSize - 1; y++) {
                    for (let x = 1; x < indoorSize - 1; x++) {
                        // Skip area around door
                        if (x >= doorX-1 && x <= doorX+1 && y >= doorY-1) continue;
                        
                        const r = Math.random();
                        if (r < 0.25) {
                            indoorMap[y][x] = { 
                                type: furniture[Math.floor(Math.random()*furniture.length)], 
                                blocks: true 
                            };
                        } else if (r < 0.28) {
                            const food = foodItems[Math.floor(Math.random()*foodItems.length)];
                            indoorMap[y][x] = { 
                                type: food, 
                                blocks: false, 
                                food: true,
                                healAmount: { 'üçé':15, 'üçó':25, 'ü•§':20 }[food]
                            };
                        } else if (r < 0.33) {
                            indoorMap[y][x] = { type: 'üì¶', blocks: false, item: true };
                        }
                    }
                }
                
                return indoorMap;
            }
            
            initWeapons() {
                this.weapons = {
                    pistol: { name: 'Pistol', damage: 20, range: 4, emoji: 'üî´', type: 'linear' },
                    rifle: { name: 'Rifle', damage: 30, range: 8, emoji: 'üéØ', type: 'linear' },
                    shotgun: { name: 'Shotgun', damage: 40, range: 2, emoji: 'üî´', type: 'shotgun' },
                    smg: { name: 'SMG', damage: 15, range: 3, emoji: 'üî´', type: 'rapid' },
                    flamethrower: { name: 'Flamethrower', damage: 25, range: 2, emoji: 'üî•', type: 'flame' },
                    sniper: { name: 'Sniper', damage: 50, range: 12, emoji: 'üéØ', type: 'linear' }
                };
            }
            
            initGear() {
                this.gearTypes = {
                    armor: { name: 'Body Armor', effect: 'damageReduction', value: 0.3, emoji: 'üõ°Ô∏è' },
                    scope: { name: 'Scope', effect: 'rangeBonus', value: 2, emoji: 'üî≠' },
                    medkit: { name: 'Medkit', effect: 'heal', value: 30, emoji: 'üíä' }
                };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.isIndoor && this.currentHouse) {
                    this.drawIndoor();
                } else {
                    this.drawOutdoor();
                }
            }
            
            drawOutdoor() {
                // Draw grass background
                this.ctx.fillStyle = '#2e7d32';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid lines
                this.ctx.strokeStyle = '#3a7d44';
                this.ctx.lineWidth = 1;
                
                // Draw tiles
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const tile = this.map[y][x];
                        const screenX = x * this.TILE_SIZE;
                        const screenY = y * this.TILE_SIZE;
                        
                        // Grid lines
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse) return;
                    this.drawPlayer(player, index, player.x, player.y);
                });
            }
            
            drawIndoor() {
                if (!this.currentHouse) return;
                
                // Draw wooden floor
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const indoorSize = 8;
                const offsetX = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                const offsetY = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                
                // Draw indoor grid
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        const screenX = x * this.TILE_SIZE + offsetX;
                        const screenY = y * this.TILE_SIZE + offsetY;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#a0522d';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw indoor players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse !== this.currentHouse) return;
                    this.drawPlayer(player, index, player.indoorPos.x, player.indoorPos.y, offsetX, offsetY);
                });
            }
            
            drawPlayer(player, index, gridX, gridY, offsetX = 0, offsetY = 0) {
                const screenX = gridX * this.TILE_SIZE + offsetX;
                const screenY = gridY * this.TILE_SIZE + offsetY;
                
                // Draw player circle
                this.ctx.fillStyle = player.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2,
                    this.TILE_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Pulsing for current player
                if (index === this.currentPlayer) {
                    this.ctx.save();
                    const pulseScale = 1 + 0.1 * Math.sin(Date.now() / 200);
                    this.ctx.translate(screenX + this.TILE_SIZE / 2, screenY + this.TILE_SIZE / 2);
                    this.ctx.scale(pulseScale, pulseScale);
                    this.ctx.translate(-(screenX + this.TILE_SIZE / 2), -(screenY + this.TILE_SIZE / 2));
                    
                    this.ctx.shadowColor = player.color;
                    this.ctx.shadowBlur = 8;
                }
                
                // Player emoji
                this.ctx.font = `${Math.max(this.TILE_SIZE * 0.5, 12)}px Arial`;
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText(
                    player.emoji,
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2
                );
                
                if (index === this.currentPlayer) {
                    this.ctx.restore();
                }
                
                // Health bar
                const barWidth = this.TILE_SIZE - 4;
                const barHeight = Math.max(3, this.TILE_SIZE * 0.08);
                const barX = screenX + 2;
                const barY = screenY - barHeight - 1;
                
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = player.hp / player.maxHp;
                const healthWidth = healthPercent * barWidth;
                
                this.ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : 
                                   healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
            }
            
            // Game actions
            rollDice() {
                if (this.hasRolled || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (player.inHouse) {
                    this.movesLeft = 99; // Infinite moves indoors
                } else {
                    // Roll 2 dice
                    this.movesLeft = Math.floor(Math.random() * 6) + 1 + 
                                    Math.floor(Math.random() * 6) + 1;
                }
                
                this.hasRolled = true;
                this.updateUI();
                this.playSound(500);
                
                alert(`üé≤ Rolled ${this.movesLeft} movement points!`);
            }
            
            startMove(dx, dy) {
                if (this.aiming) {
                    // In aim mode, move aim cursor
                    this.moveAim(dx, dy);
                    return;
                }
                
                // In movement mode, start continuous movement
                this.moveDirection = { dx, dy };
                
                // Move immediately once
                this.executeMove();
                
                // Then set up interval for continuous movement
                clearInterval(this.moveInterval);
                this.moveInterval = setInterval(() => {
                    this.executeMove();
                }, 200);
            }
            
            stopMove() {
                clearInterval(this.moveInterval);
                this.moveDirection = { dx: 0, dy: 0 };
            }
            
            executeMove() {
                if (!this.gameActive || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const { dx, dy } = this.moveDirection;
                
                if (dx === 0 && dy === 0) return;
                
                if (player.inHouse) {
                    this.movePlayerIndoor(player, dx, dy);
                } else {
                    if (this.movesLeft <= 0 && this.hasRolled) return;
                    this.movePlayerOutdoor(player, dx, dy);
                }
            }
            
            movePlayerOutdoor(player, dx, dy) {
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                // Boundary check
                if (newX < 0 || newY < 0 || newX >= this.GRID_SIZE || newY >= this.GRID_SIZE) {
                    return;
                }
                
                const tile = this.map[newY][newX];
                
                // Empty tile
                if (!tile) {
                    // Check for collision with other players
                    const collision = this.players.some(p => 
                        p.alive && p !== player && !p.inHouse && p.x === newX && p.y === newY);
                    if (collision) return;
                    
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                // Blocking tile
                if (tile.blocks) return;
                
                // House entrance
                if (tile.house) {
                    this.enterHouse(player, newX, newY);
                    return;
                }
                
                // Item crate
                if (tile.item) {
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.pickupItem(player, newX, newY);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            movePlayerIndoor(player, dx, dy) {
                if (!player.indoorPos) return;
                
                const newX = player.indoorPos.x + dx;
                const newY = player.indoorPos.y + dy;
                
                // Boundary check
                if (newX < 0 || newY < 0 || newX >= 8 || newY >= 8) return;
                
                const tile = player.inHouse.indoorMap[newY][newX];
                
                // Empty tile
                if (!tile) {
                    // Check for collision
                    const collision = this.players.find(p => 
                        p.alive && p !== player && 
                        p.inHouse === player.inHouse &&
                        p.indoorPos && p.indoorPos.x === newX && p.indoorPos.y === newY);
                    
                    if (collision) return;
                    
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                // Blocking tile
                if (tile.blocks) return;
                
                // Door (exit)
                if (tile.door) {
                    this.exitHouse(player);
                    return;
                }
                
                // Food item
                if (tile.food) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    player.hp = Math.min(player.maxHp, player.hp + tile.healAmount);
                    player.inHouse.indoorMap[newY][newX] = null;
                    this.updateUI();
                    this.draw();
                    this.playSound(700);
                    alert(`üçó Healed ${tile.healAmount} HP!`);
                    return;
                }
                
                // Item chest
                if (tile.item) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.pickupItem(player, newX, newY, true);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            enterHouse(player, houseX, houseY) {
                const house = this.houses.find(h => h.x === houseX && h.y === houseY);
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const doorX = 3;
                const doorY = 7;
                
                player.inHouse = house;
                player.indoorPos = { x: doorX, y: doorY };
                house.playersInside.push(playerIndex);
                
                this.currentHouse = house;
                this.isIndoor = true;
                this.movesLeft = 99;
                this.hasRolled = true;
                
                this.updateUI();
                this.draw();
                this.playSound(800);
                
                alert(`üè† Player ${playerIndex + 1} entered the house!`);
            }
            
            exitHouse(player) {
                const house = player.inHouse;
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const houseIndex = house.playersInside.indexOf(playerIndex);
                
                if (houseIndex > -1) {
                    house.playersInside.splice(houseIndex, 1);
                }
                
                player.x = house.entranceX;
                player.y = house.entranceY;
                player.inHouse = null;
                player.indoorPos = null;
                
                if (house.playersInside.length === 0) {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
                
                this.updateViewForCurrentPlayer();
                this.playSound(600);
                
                alert(`üö™ Player ${playerIndex + 1} exited the house!`);
            }
            
            enterAim() {
                if (this.hasShot || this.aiming) return;
                if (!this.hasRolled && !this.players[this.currentPlayer].inHouse) {
                    alert("You need to roll dice first!");
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                
                // Initialize aim at player's current position
                if (this.isIndoor && player.indoorPos) {
                    this.aim = {
                        x: player.indoorPos.x,
                        y: player.indoorPos.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                } else {
                    this.aim = {
                        x: player.x,
                        y: player.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                }
                
                this.aiming = true;
                this.updateAimCursor();
                this.updateUI();
                
                // Show status indicator
                this.statusIndicator.textContent = "üéØ AIMING MODE - Use movement buttons to aim";
                this.statusIndicator.className = "status-indicator status-aiming";
                this.statusIndicator.style.display = 'block';
                
                alert("üéØ Aiming Mode Activated!\nUse movement buttons to aim.");
            }
            
            moveAim(dx, dy) {
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                // Calculate effective range
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                // FIRST MOVE: Lock direction
                if (this.aim.dx === null && this.aim.dy === null) {
                    this.aim.dx = dx;
                    this.aim.dy = dy;
                }
                
                // SUBSEQUENT MOVES: Must match locked direction
                if (dx !== this.aim.dx || dy !== this.aim.dy) {
                    return;
                }
                
                // Range limit check
                if (this.aim.steps >= range) {
                    return;
                }
                
                const newX = this.aim.x + dx;
                const newY = this.aim.y + dy;
                
                const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                if (newX < 0 || newY < 0 || newX >= maxBound || newY >= maxBound) {
                    return;
                }
                
                // Check for obstacles
                if (this.isIndoor) {
                    const tile = this.currentHouse.indoorMap[newY][newX];
                    if (tile && tile.blocks) return;
                } else {
                    const tile = this.map[newY][newX];
                    if (tile && tile.blocks) return;
                }
                
                this.aim.x = newX;
                this.aim.y = newY;
                this.aim.steps++;
                
                this.updateAimCursor();
                this.playSound(400);
            }
            
            updateAimCursor() {
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                if (!this.aiming) return;
                
                let screenX, screenY;
                
                if (this.isIndoor) {
                    const offsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const offsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    screenX = this.aim.x * this.TILE_SIZE + offsetX;
                    screenY = this.aim.y * this.TILE_SIZE + offsetY;
                } else {
                    screenX = this.aim.x * this.TILE_SIZE;
                    screenY = this.aim.y * this.TILE_SIZE;
                }
                
                const cursor = document.createElement('div');
                cursor.className = 'aim-cell';
                cursor.style.left = screenX + 'px';
                cursor.style.top = screenY + 'px';
                cursor.style.width = this.TILE_SIZE + 'px';
                cursor.style.height = this.TILE_SIZE + 'px';
                
                this.aimOverlay.appendChild(cursor);
                
                // Shotgun preview
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                if (weapon.type === 'shotgun' && this.aim.dx !== null) {
                    const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                    
                    patterns.forEach(([dx, dy]) => {
                        const x = this.aim.x + dx;
                        const y = this.aim.y + dy;
                        
                        const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                        if (x < 0 || y < 0 || x >= maxBound || y >= maxBound) return;
                        
                        if (this.isIndoor) {
                            const tile = this.currentHouse.indoorMap[y][x];
                            if (tile && tile.blocks) return;
                        } else {
                            const tile = this.map[y][x];
                            if (tile && tile.blocks) return;
                        }
                        
                        let cellX, cellY;
                        if (this.isIndoor) {
                            const offset = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                            cellX = x * this.TILE_SIZE + offset;
                            cellY = y * this.TILE_SIZE + offset;
                        } else {
                            cellX = x * this.TILE_SIZE;
                            cellY = y * this.TILE_SIZE;
                        }
                        
                        const cell = document.createElement('div');
                        cell.className = 'shotgun-cell';
                        cell.style.left = cellX + 'px';
                        cell.style.top = cellY + 'px';
                        cell.style.width = this.TILE_SIZE + 'px';
                        cell.style.height = this.TILE_SIZE + 'px';
                        
                        this.shotgunPreview.appendChild(cell);
                    });
                }
            }
            
            getShotgunPattern(dx, dy) {
                if (dx !== 0 && dy === 0) {
                    return [[dx,0], [dx,-1], [dx,1]];
                }
                if (dy !== 0 && dx === 0) {
                    return [[0,dy], [-1,dy], [1,dy]];
                }
                return [[dx, dy]];
            }
            
            shoot() {
                if (!this.aiming || this.hasShot) return;
                
                const shooter = this.players[this.currentPlayer];
                const weapon = this.weapons[shooter.weapon];
                
                switch (weapon.type) {
                    case 'linear':
                        this.fireLinear(shooter, weapon);
                        break;
                    case 'shotgun':
                        this.fireShotgun(shooter, weapon);
                        break;
                    case 'rapid':
                        this.fireRapid(shooter, weapon);
                        break;
                    case 'flame':
                        this.fireFlamethrower(shooter, weapon);
                        break;
                }
                
                this.hasShot = true;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                this.statusIndicator.style.display = 'none';
                
                this.updateUI();
                this.draw();
            }
            
            fireLinear(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target at aimed position!");
                    return;
                }
                
                if (!this.checkLineOfSight(shooter, target)) {
                    alert('Shot blocked by cover!');
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
            }
            
            fireShotgun(shooter, weapon) {
                if (this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                let hitCount = 0;
                
                patterns.forEach(([dx, dy]) => {
                    const targetX = this.aim.x + dx;
                    const targetY = this.aim.y + dy;
                    
                    const target = this.findTargetAt(shooter, targetX, targetY);
                    if (!target) return;
                    if (!this.checkLineOfSight(shooter, target)) return;
                    
                    const pelletDamage = Math.floor(weapon.damage / 2);
                    this.applyDamage(shooter, target, pelletDamage);
                    hitCount++;
                });
                
                if (hitCount > 0) {
                    this.playSound(300, 0.2);
                } else {
                    this.playSound(200, 0.1);
                    alert("Shotgun spread missed!");
                }
            }
            
            fireRapid(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target || !this.checkLineOfSight(shooter, target)) {
                    this.playSound(200, 0.1);
                    alert("No valid target!");
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                
                setTimeout(() => {
                    if (target.alive) {
                        this.applyDamage(shooter, target, weapon.damage);
                    }
                }, 200);
                
                this.playSound(400, 0.3);
            }
            
            fireFlamethrower(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target in range!");
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                this.playSound(200, 0.4);
            }
            
            findTargetAt(shooter, targetX, targetY) {
                if (this.isIndoor) {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        p.inHouse === shooter.inHouse &&
                        p.indoorPos && p.indoorPos.x === targetX && p.indoorPos.y === targetY
                    );
                } else {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        !p.inHouse && p.x === targetX && p.y === targetY
                    );
                }
            }
            
            checkLineOfSight(shooter, target) {
                const weapon = this.weapons[shooter.weapon];
                if (weapon.type === 'flame') return true;
                
                let x1, y1, x2, y2, map;
                
                if (this.isIndoor) {
                    x1 = shooter.indoorPos.x;
                    y1 = shooter.indoorPos.y;
                    x2 = target.indoorPos.x;
                    y2 = target.indoorPos.y;
                    map = this.currentHouse.indoorMap;
                } else {
                    x1 = shooter.x;
                    y1 = shooter.y;
                    x2 = target.x;
                    y2 = target.y;
                    map = this.map;
                }
                
                // Bresenham's line algorithm
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                let x = x1;
                let y = y1;
                
                while (true) {
                    if (x !== x1 || y !== y1) {
                        if (map[y] && map[y][x] && map[y][x].blocks) {
                            return false;
                        }
                    }
                    
                    if (x === x2 && y === y2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return true;
            }
            
            applyDamage(shooter, target, baseDamage) {
                let finalDamage = baseDamage;
                
                if (target.armor && target.armor.effect === 'damageReduction') {
                    finalDamage = Math.floor(baseDamage * (1 - target.armor.value));
                }
                
                target.hp -= finalDamage;
                
                this.playSound(400 + finalDamage * 2);
                
                if (target.hp <= 0) {
                    target.alive = false;
                    target.hp = 0;
                    
                    if (target.inHouse) {
                        const house = target.inHouse;
                        const playerIndex = this.players.indexOf(target);
                        const houseIndex = house.playersInside.indexOf(playerIndex);
                        if (houseIndex > -1) {
                            house.playersInside.splice(houseIndex, 1);
                        }
                        target.inHouse = null;
                        target.indoorPos = null;
                    }
                    
                    const shooterIndex = this.players.indexOf(shooter);
                    const targetIndex = this.players.indexOf(target);
                    
                    alert(`üéØ Player ${shooterIndex + 1} eliminated Player ${targetIndex + 1}!`);
                    
                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        const winnerIndex = this.players.findIndex(p => p.alive);
                        alert(`üéâ üèÜ Player ${winnerIndex + 1} wins the game! üèÜ üéâ`);
                        this.gameActive = false;
                    }
                }
                
                this.updateUI();
            }
            
            pickupItem(player, x, y, indoor = false) {
                const weapons = ['pistol', 'rifle', 'shotgun', 'smg', 'flamethrower', 'sniper'];
                const gearTypes = ['armor', 'scope', 'medkit'];
                
                const isWeapon = Math.random() > 0.5;
                
                if (isWeapon) {
                    const newWeapon = weapons[Math.floor(Math.random() * weapons.length)];
                    const oldWeapon = player.weapon;
                    player.weapon = newWeapon;
                    
                    alert(`üî´ Found ${this.weapons[newWeapon].name}!\nReplaced your ${this.weapons[oldWeapon].name}`);
                } else {
                    const gearType = gearTypes[Math.floor(Math.random() * gearTypes.length)];
                    const gear = { ...this.gearTypes[gearType] };
                    
                    if (gearType === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + gear.value);
                        alert(`üíä Found Medkit!\nHealed ${gear.value} HP.`);
                    } else if (gearType === 'armor') {
                        player.armor = gear;
                        alert(`üõ°Ô∏è Found Body Armor!\nNow reduces damage by 30%`);
                    } else {
                        player.gear.push(gear);
                        alert(`üî≠ Found Scope!\n+${gear.value} to weapon range`);
                    }
                }
                
                if (indoor) {
                    player.inHouse.indoorMap[y][x] = null;
                } else {
                    this.map[y][x] = null;
                }
                
                this.updateUI();
            }
            
            endTurn() {
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                this.statusIndicator.style.display = 'none';
                
                let attempts = 0;
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % 4;
                    attempts++;
                    if (attempts > 4) break;
                } while (!this.players[this.currentPlayer].alive);
                
                this.updateViewForCurrentPlayer();
                this.updateUI();
                this.draw();
                
                alert(`‚Ü™Ô∏è Turn passed to Player ${this.currentPlayer + 1}`);
            }
            
            updateViewForCurrentPlayer() {
                const currentPlayer = this.players[this.currentPlayer];
                
                if (currentPlayer.inHouse) {
                    this.currentHouse = currentPlayer.inHouse;
                    this.isIndoor = true;
                } else {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
            }
            
            updateUI() {
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                // Update mini info
                this.miniPlayer.textContent = `P${this.currentPlayer + 1} ${player.emoji}`;
                
                if (this.aiming) {
                    this.miniMoves.textContent = "Aiming...";
                } else if (player.inHouse) {
                    this.miniMoves.textContent = "Indoors ‚àû moves";
                } else if (this.hasRolled) {
                    this.miniMoves.textContent = `${this.movesLeft} moves left`;
                } else {
                    this.miniMoves.textContent = "Roll dice!";
                }
                
                // Update weapon info
                this.miniWeapon.textContent = weapon.name;
                
                // Calculate effective range
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                this.miniRange.textContent = `Range: ${range}`;
                this.miniDamage.textContent = `Dmg: ${weapon.damage}`;
                
                // Update player info panel
                this.updatePlayerInfoPanel();
                
                // Update button states
                const rollBtn = document.querySelector('.action-btn.roll');
                const aimBtn = document.querySelector('.action-btn.aim');
                const shootBtn = document.querySelector('.action-btn.shoot');
                const endBtn = document.querySelector('.action-btn.end');
                
                rollBtn.disabled = this.hasRolled || this.aiming || player.inHouse;
                aimBtn.disabled = this.hasShot || this.aiming || (!this.hasRolled && !player.inHouse);
                shootBtn.disabled = !this.aiming;
                endBtn.disabled = false;
                
                [rollBtn, aimBtn, shootBtn, endBtn].forEach(btn => {
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                });
            }
            
            updatePlayerInfoPanel() {
                const playersInfo = document.getElementById('players-info');
                playersInfo.innerHTML = '';
                
                this.players.forEach((player, index) => {
                    if (!player.alive) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'player-info';
                        playerDiv.innerHTML = `
                            <div class="player-header">
                                <span class="player-emoji">üíÄ</span>
                                <span class="player-name">Player ${index + 1} (Eliminated)</span>
                            </div>
                        `;
                        playersInfo.appendChild(playerDiv);
                        return;
                    }
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player-info ${index === this.currentPlayer ? 'current' : ''}`;
                    
                    const weapon = this.weapons[player.weapon];
                    const armorEmoji = player.armor ? player.armor.emoji : '';
                    const gearList = player.gear.map(g => g.emoji).join(' ');
                    
                    let range = weapon.range;
                    player.gear.forEach(g => {
                        if (g.effect === 'rangeBonus') range += g.value;
                    });
                    
                    playerDiv.innerHTML = `
                        <div class="player-header">
                            <span class="player-emoji">${player.emoji}</span>
                            <span class="player-name">Player ${index + 1}</span>
                            ${player.inHouse ? '<span style="color:#9b59b6;">üè†</span>' : ''}
                            ${index === this.currentPlayer ? '<span style="color:#3498db;">‚ñ∂Ô∏è</span>' : ''}
                        </div>
                        <div class="player-hp">
                            <div class="player-hp-bar" style="width: ${(player.hp/player.maxHp)*100}%"></div>
                        </div>
                        <div class="player-stats">
                            <div class="stat-item">
                                <span class="stat-label">Weapon:</span>
                                <span>${weapon.emoji} ${weapon.name}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Range:</span>
                                <span>${range} tiles</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Damage:</span>
                                <span>${weapon.damage}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Armor:</span>
                                <span>${armorEmoji || 'None'}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Gear:</span>
                                <span>${gearList || 'None'}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Moves:</span>
                                <span>${player.inHouse ? '‚àû' : (index === this.currentPlayer && this.hasRolled ? this.movesLeft : '-')}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Health:</span>
                                <span>${player.hp}/${player.maxHp}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Location:</span>
                                <span>${player.inHouse ? 'Indoors' : 'Outdoors'}</span>
                            </div>
                        </div>
                    `;
                    
                    playersInfo.appendChild(playerDiv);
                });
            }
            
            playSound(frequency, duration = 0.1, type = 'sine') {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Sound effect');
                }
            }
        }

        // Initialize game
        let game;

        function initGame() {
            game = new MobileBattleRoyale();
        }

        // Global functions
        function startMove(dx, dy) {
            if (game) game.startMove(dx, dy);
        }

        function stopMove() {
            if (game) game.stopMove();
        }

        function rollDice() {
            if (game) game.rollDice();
        }

        function enterAim() {
            if (game) game.enterAim();
        }

        function shoot() {
            if (game) game.shoot();
        }

        function endTurn() {
            if (game) game.endTurn();
        }

        function showPlayerInfo() {
            document.getElementById('player-info-panel').classList.add('active');
        }

        function hidePlayerInfo() {
            document.getElementById('player-info-panel').classList.remove('active');
        }

        function showRules() {
            document.getElementById('rules-panel').classList.add('active');
        }

        function hideRules() {
            document.getElementById('rules-panel').classList.remove('active');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initGame);

        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
