<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        /* Landscape warning - unskippable */
        #landscape-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            text-align: center;
        }

        #landscape-warning h1 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #landscape-warning p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #landscape-warning .rotate-icon {
            font-size: 60px;
            margin: 20px 0;
            animation: rotate 2s infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
        }

        /* Main game layout - optimized for landscape */
        #game-container {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Game area - side by side on landscape */
        .game-area {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding: 5px;
            gap: 5px;
        }

        /* Top bar */
        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(45, 52, 54, 0.9);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 10;
            flex-shrink: 0;
        }

        /* Turn indicator */
        #turn-indicator {
            font-weight: 600;
            padding: 8px 15px;
            border-radius: 20px;
            background: rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
            border: 2px solid #3498db;
            min-width: 180px;
            text-align: center;
            font-size: 14px;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px #3498db; }
            50% { box-shadow: 0 0 20px #3498db; }
        }

        /* Info button */
        #info-btn {
            background: #9b59b6;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Canvas area - takes most space */
        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background: #2d3436;
            border-radius: 10px;
        }

        canvas {
            display: block;
            background: #2d3436;
            border-radius: 8px;
            max-width: 95%;
            max-height: 95%;
            touch-action: none;
        }

        /* Controls area - fixed bottom */
        #controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: rgba(45, 52, 54, 0.9);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }

        /* Action buttons row */
        .action-row {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }

        .action-btn {
            flex: 1;
            height: 45px;
            background: #3498db;
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            min-width: 0;
            padding: 0 5px;
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .action-btn.roll { background: #f39c12; }
        .action-btn.aim { background: #e74c3c; }
        .action-btn.shoot { background: #c0392b; }
        .action-btn.end { background: #7f8c8d; }

        /* Movement controls row */
        .movement-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }

        #movement-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 8px;
        }

        .movement-btn {
            width: 55px;
            height: 55px;
            background: #34495e;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.1s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .movement-btn:active {
            background: #2c3e50;
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .movement-btn.up { grid-area: up; }
        .movement-btn.left { grid-area: left; }
        .movement-btn.right { grid-area: right; }
        .movement-btn.down { grid-area: down; }

        /* Info panel */
        #info-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
        }

        #info-panel.active {
            display: flex;
        }

        .panel-content {
            background: rgba(45, 52, 54, 0.95);
            margin: 20px;
            border-radius: 20px;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #34495e;
        }

        .panel-header h2 {
            color: #3498db;
            font-size: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
        }

        .players-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .player-info {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .player-info.current {
            border-left: 4px solid #3498db;
            background: rgba(52, 73, 94, 0.8);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .player-emoji {
            font-size: 24px;
        }

        .player-name {
            font-weight: 600;
            font-size: 16px;
        }

        .player-hp {
            width: 100%;
            height: 8px;
            background: #2c3e50;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .player-hp-bar {
            height: 100%;
            background: #2ecc71;
            border-radius: 4px;
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #95a5a6;
        }

        .game-guide {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 12px;
            padding: 15px;
            margin-top: 10px;
        }

        .game-guide h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .game-guide ul {
            padding-left: 20px;
            color: #ecf0f1;
            font-size: 13px;
            line-height: 1.5;
        }

        /* Aim overlay */
        #aim-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .aim-cell {
            position: absolute;
            background: rgba(255, 255, 0, 0.3);
            border: 2px solid yellow;
            border-radius: 4px;
            animation: pulse-aim 0.8s infinite;
        }

        @keyframes pulse-aim {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .shotgun-cell {
            position: absolute;
            background: rgba(255, 165, 0, 0.3);
            border: 2px solid orange;
            border-radius: 4px;
        }

        /* Mobile optimization */
        @media (max-height: 600px) {
            .movement-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .action-btn {
                height: 40px;
                font-size: 13px;
            }
            
            #turn-indicator {
                font-size: 12px;
                min-width: 150px;
            }
        }

        @media (orientation: portrait) {
            #game-container {
                display: none !important;
            }
            #landscape-warning {
                display: flex !important;
            }
        }
    </style>
</head>
<body>
    <!-- Landscape warning -->
    <div id="landscape-warning">
        <h1>üîÑ Please Rotate Your Device</h1>
        <div class="rotate-icon">üì±</div>
        <p>This game is optimized for landscape mode.<br>Please rotate your device to play.</p>
        <p><small>If rotation doesn't work, check your device's orientation lock.</small></p>
    </div>

    <!-- Main game container -->
    <div id="game-container">
        <div class="game-area">
            <!-- Top bar with turn indicator -->
            <div id="top-bar">
                <div id="turn-indicator">
                    Player <span id="current-player-num">1</span>'s Turn
                    <div id="turn-details" style="font-size: 12px; opacity: 0.8;"></div>
                </div>
                <button id="info-btn" onclick="toggleInfoPanel()">‚ÑπÔ∏è</button>
            </div>

            <!-- Canvas area -->
            <div class="canvas-area">
                <canvas id="gameCanvas"></canvas>
                <div id="aim-overlay"></div>
                <div id="shotgun-preview"></div>
            </div>

            <!-- Controls area -->
            <div id="controls">
                <!-- Action buttons -->
                <div class="action-row">
                    <button class="action-btn roll" onclick="rollDice()">
                        <span>üé≤</span> Roll Dice
                    </button>
                    <button class="action-btn aim" onclick="enterAim()">
                        <span>üéØ</span> Aim
                    </button>
                    <button class="action-btn shoot" onclick="shoot()">
                        <span>üî´</span> Shoot
                    </button>
                    <button class="action-btn end" onclick="endTurn()">
                        <span>‚è≠Ô∏è</span> End Turn
                    </button>
                </div>

                <!-- Movement controls -->
                <div class="movement-row">
                    <div id="movement-controls">
                        <button class="movement-btn up" onpointerdown="startMove(0, -1)" onpointerup="stopMove()">‚Üë</button>
                        <button class="movement-btn left" onpointerdown="startMove(-1, 0)" onpointerup="stopMove()">‚Üê</button>
                        <button class="movement-btn right" onpointerdown="startMove(1, 0)" onpointerup="stopMove()">‚Üí</button>
                        <button class="movement-btn down" onpointerdown="startMove(0, 1)" onpointerup="stopMove()">‚Üì</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Info panel -->
        <div id="info-panel">
            <div class="panel-content">
                <div class="panel-header">
                    <h2>üìä Game Information</h2>
                    <button class="close-btn" onclick="toggleInfoPanel()">‚úï</button>
                </div>
                <div class="players-list" id="players-info">
                    <!-- Player info will be inserted here -->
                </div>
                <div class="game-guide">
                    <h3>üéÆ How to Play</h3>
                    <ul>
                        <li><strong>Roll Dice</strong> to get movement points</li>
                        <li><strong>Move</strong> your character with the D-pad</li>
                        <li><strong>Aim</strong> at opponents to attack</li>
                        <li><strong>Shoot</strong> when ready to fire</li>
                        <li><strong>End Turn</strong> to pass to next player</li>
                        <li>Enter <strong>Houses</strong> for loot and cover</li>
                        <li>Pick up <strong>Items</strong> to get better gear</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Mobile Battle Royale Game
        class MobileBattleRoyale {
            constructor() {
                // Core grid constants - optimized for mobile
                this.GRID_SIZE = 15;
                this.INDOOR_SIZE = 8;
                this.TILE_SIZE = 40;
                this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                
                // Game elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.aimOverlay = document.getElementById('aim-overlay');
                this.shotgunPreview = document.getElementById('shotgun-preview');
                this.turnIndicator = document.getElementById('turn-indicator');
                this.turnDetails = document.getElementById('turn-details');
                this.currentPlayerNum = document.getElementById('current-player-num');
                
                // Setup canvas
                this.setupCanvas();
                
                // Game state
                this.gameActive = true;
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasRolled = false;
                this.hasShot = false;
                this.aiming = false;
                this.isIndoor = false;
                this.currentHouse = null;
                
                // Movement interval
                this.moveInterval = null;
                this.moveDirection = { dx: 0, dy: 0 };
                
                // Aim state
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                
                // Initialize game
                this.initPlayers();
                this.initMap();
                this.initWeapons();
                this.initGear();
                this.updateUI();
                this.draw();
                
                // Event listeners
                window.addEventListener('resize', () => this.handleResize());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.checkOrientation(), 100);
                });
                
                this.handleResize();
                this.checkOrientation();
            }
            
            setupCanvas() {
                // Set canvas size
                this.canvas.width = this.CANVAS_SIZE;
                this.canvas.height = this.CANVAS_SIZE;
                
                // Setup context
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            handleResize() {
                const container = document.querySelector('.canvas-area');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Calculate scale to fit canvas in container
                const scale = Math.min(
                    containerWidth / this.CANVAS_SIZE,
                    containerHeight / this.CANVAS_SIZE
                );
                
                // Apply scale transform
                this.canvas.style.transform = `scale(${scale})`;
                this.canvas.style.transformOrigin = 'center center';
                
                // Update aim overlay scale
                if (this.aimOverlay) {
                    this.aimOverlay.style.transform = `scale(${scale})`;
                    this.aimOverlay.style.transformOrigin = 'center center';
                    this.aimOverlay.style.width = `${this.CANVAS_SIZE}px`;
                    this.aimOverlay.style.height = `${this.CANVAS_SIZE}px`;
                }
                
                if (this.shotgunPreview) {
                    this.shotgunPreview.style.transform = `scale(${scale})`;
                    this.shotgunPreview.style.transformOrigin = 'center center';
                    this.shotgunPreview.style.width = `${this.CANVAS_SIZE}px`;
                    this.shotgunPreview.style.height = `${this.CANVAS_SIZE}px`;
                }
                
                // Redraw if game is active
                if (this.gameActive) {
                    this.draw();
                    if (this.aiming) {
                        this.updateAimCursor();
                    }
                }
            }
            
            checkOrientation() {
                const warning = document.getElementById('landscape-warning');
                const gameContainer = document.getElementById('game-container');
                
                // Check if device is in landscape
                const isLandscape = window.innerWidth > window.innerHeight;
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isLandscape || !isMobile) {
                    warning.style.display = 'none';
                    gameContainer.style.display = 'block';
                    this.handleResize();
                } else {
                    warning.style.display = 'flex';
                    gameContainer.style.display = 'none';
                }
            }
            
            initPlayers() {
                this.players = [
                    {
                        x: 0, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üòé',
                        color: '#3498db'
                    },
                    {
                        x: 0, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü§†',
                        color: '#e74c3c'
                    },
                    {
                        x: 14, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü¶π',
                        color: '#2ecc71'
                    },
                    {
                        x: 14, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üßô',
                        color: '#f39c12'
                    }
                ];
            }
            
            initMap() {
                this.map = [];
                this.houses = [];
                
                // Create 15x15 grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const r = Math.random();
                        
                        if (r < 0.08) {
                            this.map[y][x] = { type: 'üå≥', blocks: true, cover: true };
                        } else if (r < 0.14) {
                            this.map[y][x] = { type: 'ü™®', blocks: true, cover: true };
                        } else if (r < 0.16) {
                            this.map[y][x] = { type: 'üè†', blocks: false, house: true };
                            this.houses.push({
                                x: x, y: y,
                                entranceX: x, entranceY: y,
                                indoorMap: this.createIndoorMap(),
                                playersInside: []
                            });
                        } else if (r < 0.20) {
                            this.map[y][x] = { type: 'üì¶', blocks: false, item: true };
                        } else {
                            this.map[y][x] = null;
                        }
                    }
                }
                
                // Clear corners for spawn points
                const corners = [[0,14], [0,0], [14,0], [14,14]];
                corners.forEach(([x,y]) => {
                    this.map[y][x] = null;
                });
            }
            
            createIndoorMap() {
                const indoorSize = 8;
                const indoorMap = [];
                
                for (let y = 0; y < indoorSize; y++) {
                    indoorMap[y] = [];
                    for (let x = 0; x < indoorSize; x++) {
                        indoorMap[y][x] = null;
                    }
                }
                
                // Place door
                const doorX = Math.floor(indoorSize / 2) - 1;
                const doorY = indoorSize - 1;
                indoorMap[doorY][doorX] = { type: 'üö™', blocks: false, door: true };
                
                // Walls
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        if (x === 0 || y === 0 || x === indoorSize-1 || y === indoorSize-1) {
                            if (x === doorX && y === doorY) continue;
                            indoorMap[y][x] = { type: 'üß±', blocks: true };
                        }
                    }
                }
                
                // Furniture and items
                const furniture = ['üõãÔ∏è', 'üì∫', 'ü™ë', 'üõèÔ∏è'];
                const foodItems = ['üçé', 'üçó', 'ü•§'];
                
                for (let y = 1; y < indoorSize - 1; y++) {
                    for (let x = 1; x < indoorSize - 1; x++) {
                        // Skip area around door
                        if (x >= doorX-1 && x <= doorX+1 && y >= doorY-1) continue;
                        
                        const r = Math.random();
                        if (r < 0.25) {
                            indoorMap[y][x] = { 
                                type: furniture[Math.floor(Math.random()*furniture.length)], 
                                blocks: true 
                            };
                        } else if (r < 0.28) {
                            const food = foodItems[Math.floor(Math.random()*foodItems.length)];
                            indoorMap[y][x] = { 
                                type: food, 
                                blocks: false, 
                                food: true,
                                healAmount: { 'üçé':15, 'üçó':25, 'ü•§':20 }[food]
                            };
                        } else if (r < 0.33) {
                            indoorMap[y][x] = { type: 'üì¶', blocks: false, item: true };
                        }
                    }
                }
                
                return indoorMap;
            }
            
            initWeapons() {
                this.weapons = {
                    pistol: { name: 'Pistol', damage: 20, range: 4, emoji: 'üî´', type: 'linear' },
                    rifle: { name: 'Rifle', damage: 30, range: 8, emoji: 'üéØ', type: 'linear' },
                    shotgun: { name: 'Shotgun', damage: 40, range: 2, emoji: 'üî´', type: 'shotgun' },
                    smg: { name: 'SMG', damage: 15, range: 3, emoji: 'üî´', type: 'rapid' },
                    flamethrower: { name: 'Flamethrower', damage: 25, range: 2, emoji: 'üî•', type: 'flame' },
                    sniper: { name: 'Sniper', damage: 50, range: 12, emoji: 'üéØ', type: 'linear' }
                };
            }
            
            initGear() {
                this.gearTypes = {
                    armor: { name: 'Body Armor', effect: 'damageReduction', value: 0.3, emoji: 'üõ°Ô∏è' },
                    scope: { name: 'Scope', effect: 'rangeBonus', value: 2, emoji: 'üî≠' },
                    medkit: { name: 'Medkit', effect: 'heal', value: 30, emoji: 'üíä' }
                };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.isIndoor && this.currentHouse) {
                    this.drawIndoor();
                } else {
                    this.drawOutdoor();
                }
            }
            
            drawOutdoor() {
                // Draw grass background
                this.ctx.fillStyle = '#2e7d32';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const tile = this.map[y][x];
                        const screenX = x * this.TILE_SIZE;
                        const screenY = y * this.TILE_SIZE;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#3a7d44';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse) return;
                    this.drawPlayer(player, index, player.x, player.y);
                });
            }
            
            drawIndoor() {
                if (!this.currentHouse) return;
                
                // Draw wooden floor
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const indoorSize = 8;
                const offsetX = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                const offsetY = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                
                // Draw indoor grid
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        const screenX = x * this.TILE_SIZE + offsetX;
                        const screenY = y * this.TILE_SIZE + offsetY;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#a0522d';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw indoor players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse !== this.currentHouse) return;
                    this.drawPlayer(player, index, player.indoorPos.x, player.indoorPos.y, offsetX, offsetY);
                });
            }
            
            drawPlayer(player, index, gridX, gridY, offsetX = 0, offsetY = 0) {
                const screenX = gridX * this.TILE_SIZE + offsetX;
                const screenY = gridY * this.TILE_SIZE + offsetY;
                
                // Draw player circle
                this.ctx.fillStyle = player.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2,
                    this.TILE_SIZE / 2 - 4,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Pulsing for current player
                if (index === this.currentPlayer) {
                    this.ctx.save();
                    const pulseScale = 1 + 0.1 * Math.sin(Date.now() / 200);
                    this.ctx.translate(screenX + this.TILE_SIZE / 2, screenY + this.TILE_SIZE / 2);
                    this.ctx.scale(pulseScale, pulseScale);
                    this.ctx.translate(-(screenX + this.TILE_SIZE / 2), -(screenY + this.TILE_SIZE / 2));
                    
                    this.ctx.shadowColor = player.color;
                    this.ctx.shadowBlur = 10;
                }
                
                // Player emoji
                this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText(
                    player.emoji,
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2
                );
                
                if (index === this.currentPlayer) {
                    this.ctx.restore();
                }
                
                // Health bar
                const barWidth = this.TILE_SIZE - 8;
                const barHeight = 4;
                const barX = screenX + 4;
                const barY = screenY - 6;
                
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = player.hp / player.maxHp;
                const healthWidth = healthPercent * barWidth;
                
                this.ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : 
                                   healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
            }
            
            // Game actions
            rollDice() {
                if (this.hasRolled || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (player.inHouse) {
                    this.movesLeft = 99; // Infinite moves indoors
                } else {
                    // Roll 2 dice
                    this.movesLeft = Math.floor(Math.random() * 6) + 1 + 
                                    Math.floor(Math.random() * 6) + 1;
                }
                
                this.hasRolled = true;
                this.updateUI();
                this.playSound(500);
                
                // Show dice roll result
                alert(`üé≤ Rolled ${this.movesLeft} movement points!`);
            }
            
            startMove(dx, dy) {
                if (this.aiming) {
                    // In aim mode, move aim cursor
                    this.moveAim(dx, dy);
                    return;
                }
                
                // In movement mode, start continuous movement
                this.moveDirection = { dx, dy };
                
                // Move immediately once
                this.executeMove();
                
                // Then set up interval for continuous movement
                clearInterval(this.moveInterval);
                this.moveInterval = setInterval(() => {
                    this.executeMove();
                }, 200); // Move every 200ms while button is held
            }
            
            stopMove() {
                clearInterval(this.moveInterval);
                this.moveDirection = { dx: 0, dy: 0 };
            }
            
            executeMove() {
                if (!this.gameActive || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const { dx, dy } = this.moveDirection;
                
                if (dx === 0 && dy === 0) return;
                
                if (player.inHouse) {
                    this.movePlayerIndoor(player, dx, dy);
                } else {
                    if (this.movesLeft <= 0 && this.hasRolled) return;
                    this.movePlayerOutdoor(player, dx, dy);
                }
            }
            
            movePlayerOutdoor(player, dx, dy) {
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                // Boundary check
                if (newX < 0 || newY < 0 || newX >= this.GRID_SIZE || newY >= this.GRID_SIZE) {
                    return;
                }
                
                const tile = this.map[newY][newX];
                
                // Empty tile
                if (!tile) {
                    // Check for collision with other players
                    const collision = this.players.some(p => 
                        p.alive && p !== player && !p.inHouse && p.x === newX && p.y === newY);
                    if (collision) return;
                    
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                // Blocking tile
                if (tile.blocks) return;
                
                // House entrance
                if (tile.house) {
                    this.enterHouse(player, newX, newY);
                    return;
                }
                
                // Item crate
                if (tile.item) {
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.pickupItem(player, newX, newY);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            movePlayerIndoor(player, dx, dy) {
                if (!player.indoorPos) return;
                
                const newX = player.indoorPos.x + dx;
                const newY = player.indoorPos.y + dy;
                
                // Boundary check
                if (newX < 0 || newY < 0 || newX >= 8 || newY >= 8) return;
                
                const tile = player.inHouse.indoorMap[newY][newX];
                
                // Empty tile
                if (!tile) {
                    // Check for collision
                    const collision = this.players.find(p => 
                        p.alive && p !== player && 
                        p.inHouse === player.inHouse &&
                        p.indoorPos && p.indoorPos.x === newX && p.indoorPos.y === newY);
                    
                    if (collision) return;
                    
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                // Blocking tile
                if (tile.blocks) return;
                
                // Door (exit)
                if (tile.door) {
                    this.exitHouse(player);
                    return;
                }
                
                // Food item
                if (tile.food) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    player.hp = Math.min(player.maxHp, player.hp + tile.healAmount);
                    player.inHouse.indoorMap[newY][newX] = null;
                    this.updateUI();
                    this.draw();
                    this.playSound(700);
                    alert(`üçó Healed ${tile.healAmount} HP!`);
                    return;
                }
                
                // Item chest
                if (tile.item) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.pickupItem(player, newX, newY, true);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            enterHouse(player, houseX, houseY) {
                const house = this.houses.find(h => h.x === houseX && h.y === houseY);
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const doorX = 3; // Center of 8x8 grid
                const doorY = 7; // Bottom row
                
                player.inHouse = house;
                player.indoorPos = { x: doorX, y: doorY };
                house.playersInside.push(playerIndex);
                
                this.currentHouse = house;
                this.isIndoor = true;
                this.movesLeft = 99; // Infinite moves indoors
                this.hasRolled = true; // Skip dice roll indoors
                
                this.updateUI();
                this.draw();
                this.playSound(800);
                
                alert(`üè† Player ${playerIndex + 1} entered the house!`);
            }
            
            exitHouse(player) {
                const house = player.inHouse;
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const houseIndex = house.playersInside.indexOf(playerIndex);
                
                if (houseIndex > -1) {
                    house.playersInside.splice(houseIndex, 1);
                }
                
                // Return to outdoor position at house entrance
                player.x = house.entranceX;
                player.y = house.entranceY;
                player.inHouse = null;
                player.indoorPos = null;
                
                // If no players left in house, exit indoor view
                if (house.playersInside.length === 0) {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
                
                this.updateViewForCurrentPlayer();
                this.playSound(600);
                
                alert(`üö™ Player ${playerIndex + 1} exited the house!`);
            }
            
            enterAim() {
                if (this.hasShot || this.aiming) return;
                if (!this.hasRolled && !this.players[this.currentPlayer].inHouse) {
                    alert("You need to roll dice first!");
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                
                // Initialize aim at player's current position
                if (this.isIndoor && player.indoorPos) {
                    this.aim = {
                        x: player.indoorPos.x,
                        y: player.indoorPos.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                } else {
                    this.aim = {
                        x: player.x,
                        y: player.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                }
                
                this.aiming = true;
                this.updateAimCursor();
                this.updateUI();
                
                alert("üéØ Aiming Mode Activated!\nUse movement buttons to aim.");
            }
            
            moveAim(dx, dy) {
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                // Calculate effective range (weapon range + scope bonuses)
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                // FIRST MOVE: Lock direction
                if (this.aim.dx === null && this.aim.dy === null) {
                    this.aim.dx = dx;
                    this.aim.dy = dy;
                }
                
                // SUBSEQUENT MOVES: Must match locked direction
                if (dx !== this.aim.dx || dy !== this.aim.dy) {
                    return; // Reject movement in different direction
                }
                
                // Range limit check
                if (this.aim.steps >= range) {
                    return; // Cannot aim beyond weapon range
                }
                
                // Calculate new aim position
                const newX = this.aim.x + dx;
                const newY = this.aim.y + dy;
                
                // Boundary check
                const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                if (newX < 0 || newY < 0 || newX >= maxBound || newY >= maxBound) {
                    return; // Out of bounds
                }
                
                // Check for obstacles in line of sight
                if (this.isIndoor) {
                    const tile = this.currentHouse.indoorMap[newY][newX];
                    if (tile && tile.blocks) return;
                } else {
                    const tile = this.map[newY][newX];
                    if (tile && tile.blocks) return;
                }
                
                // VALID MOVE: Update aim cursor
                this.aim.x = newX;
                this.aim.y = newY;
                this.aim.steps++;
                
                this.updateAimCursor();
                this.playSound(400);
            }
            
            updateAimCursor() {
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                if (!this.aiming) return;
                
                let screenX, screenY;
                
                if (this.isIndoor) {
                    const offsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const offsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    screenX = this.aim.x * this.TILE_SIZE + offsetX;
                    screenY = this.aim.y * this.TILE_SIZE + offsetY;
                } else {
                    screenX = this.aim.x * this.TILE_SIZE;
                    screenY = this.aim.y * this.TILE_SIZE;
                }
                
                // Create aim cursor
                const cursor = document.createElement('div');
                cursor.className = 'aim-cell';
                cursor.style.left = screenX + 'px';
                cursor.style.top = screenY + 'px';
                cursor.style.width = this.TILE_SIZE + 'px';
                cursor.style.height = this.TILE_SIZE + 'px';
                
                this.aimOverlay.appendChild(cursor);
                
                // Shotgun spread preview
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                if (weapon.type === 'shotgun' && this.aim.dx !== null) {
                    const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                    
                    patterns.forEach(([dx, dy]) => {
                        const x = this.aim.x + dx;
                        const y = this.aim.y + dy;
                        
                        const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                        if (x < 0 || y < 0 || x >= maxBound || y >= maxBound) return;
                        
                        // Check if tile is walkable (not blocked)
                        if (this.isIndoor) {
                            const tile = this.currentHouse.indoorMap[y][x];
                            if (tile && tile.blocks) return;
                        } else {
                            const tile = this.map[y][x];
                            if (tile && tile.blocks) return;
                        }
                        
                        let cellX, cellY;
                        if (this.isIndoor) {
                            const offset = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                            cellX = x * this.TILE_SIZE + offset;
                            cellY = y * this.TILE_SIZE + offset;
                        } else {
                            cellX = x * this.TILE_SIZE;
                            cellY = y * this.TILE_SIZE;
                        }
                        
                        const cell = document.createElement('div');
                        cell.className = 'shotgun-cell';
                        cell.style.left = cellX + 'px';
                        cell.style.top = cellY + 'px';
                        cell.style.width = this.TILE_SIZE + 'px';
                        cell.style.height = this.TILE_SIZE + 'px';
                        
                        this.shotgunPreview.appendChild(cell);
                    });
                }
            }
            
            getShotgunPattern(dx, dy) {
                if (dx !== 0 && dy === 0) {
                    return [[dx,0], [dx,-1], [dx,1]];
                }
                if (dy !== 0 && dx === 0) {
                    return [[0,dy], [-1,dy], [1,dy]];
                }
                return [[dx, dy]];
            }
            
            shoot() {
                if (!this.aiming || this.hasShot) return;
                
                const shooter = this.players[this.currentPlayer];
                const weapon = this.weapons[shooter.weapon];
                
                switch (weapon.type) {
                    case 'linear':
                        this.fireLinear(shooter, weapon);
                        break;
                    case 'shotgun':
                        this.fireShotgun(shooter, weapon);
                        break;
                    case 'rapid':
                        this.fireRapid(shooter, weapon);
                        break;
                    case 'flame':
                        this.fireFlamethrower(shooter, weapon);
                        break;
                }
                
                this.hasShot = true;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                this.updateUI();
                this.draw();
            }
            
            findTargetAt(shooter, targetX, targetY) {
                if (this.isIndoor) {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        p.inHouse === shooter.inHouse &&
                        p.indoorPos && p.indoorPos.x === targetX && p.indoorPos.y === targetY
                    );
                } else {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        !p.inHouse && p.x === targetX && p.y === targetY
                    );
                }
            }
            
            fireLinear(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target at aimed position!");
                    return;
                }
                
                if (!this.checkLineOfSight(shooter, target)) {
                    alert('Shot blocked by cover!');
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
            }
            
            fireShotgun(shooter, weapon) {
                if (this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                let hitCount = 0;
                
                patterns.forEach(([dx, dy]) => {
                    const targetX = this.aim.x + dx;
                    const targetY = this.aim.y + dy;
                    
                    const target = this.findTargetAt(shooter, targetX, targetY);
                    if (!target) return;
                    if (!this.checkLineOfSight(shooter, target)) return;
                    
                    const pelletDamage = Math.floor(weapon.damage / 2);
                    this.applyDamage(shooter, target, pelletDamage);
                    hitCount++;
                });
                
                if (hitCount > 0) {
                    this.playSound(300, 0.2);
                } else {
                    this.playSound(200, 0.1);
                    alert("Shotgun spread missed!");
                }
            }
            
            fireRapid(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target || !this.checkLineOfSight(shooter, target)) {
                    this.playSound(200, 0.1);
                    alert("No valid target!");
                    return;
                }
                
                // First shot
                this.applyDamage(shooter, target, weapon.damage);
                
                // Second shot after delay
                setTimeout(() => {
                    if (target.alive) {
                        this.applyDamage(shooter, target, weapon.damage);
                    }
                }, 200);
                
                this.playSound(400, 0.3);
            }
            
            fireFlamethrower(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    alert("No target in range!");
                    return;
                }
                
                // Flamethrower ignores line of sight
                this.applyDamage(shooter, target, weapon.damage);
                this.playSound(200, 0.4);
            }
            
            checkLineOfSight(shooter, target) {
                const weapon = this.weapons[shooter.weapon];
                if (weapon.type === 'flame') return true;
                
                let x1, y1, x2, y2, map;
                
                if (this.isIndoor) {
                    x1 = shooter.indoorPos.x;
                    y1 = shooter.indoorPos.y;
                    x2 = target.indoorPos.x;
                    y2 = target.indoorPos.y;
                    map = this.currentHouse.indoorMap;
                } else {
                    x1 = shooter.x;
                    y1 = shooter.y;
                    x2 = target.x;
                    y2 = target.y;
                    map = this.map;
                }
                
                // Bresenham's line algorithm
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                let x = x1;
                let y = y1;
                
                while (true) {
                    // Skip shooter's starting position
                    if (x !== x1 || y !== y1) {
                        // Check if current grid tile blocks line of sight
                        if (map[y] && map[y][x] && map[y][x].blocks) {
                            return false; // Obstacle found
                        }
                    }
                    
                    // Reached target
                    if (x === x2 && y === y2) break;
                    
                    // Bresenham step
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return true; // Clear line of sight
            }
            
            applyDamage(shooter, target, baseDamage) {
                let finalDamage = baseDamage;
                
                // Apply armor reduction
                if (target.armor && target.armor.effect === 'damageReduction') {
                    finalDamage = Math.floor(baseDamage * (1 - target.armor.value));
                }
                
                // Apply damage
                target.hp -= finalDamage;
                
                // Visual and audio feedback
                this.showDamageEffect(target, finalDamage);
                this.playSound(400 + finalDamage * 2);
                
                // Check for elimination
                if (target.hp <= 0) {
                    target.alive = false;
                    target.hp = 0;
                    
                    // Remove from house if indoors
                    if (target.inHouse) {
                        const house = target.inHouse;
                        const playerIndex = this.players.indexOf(target);
                        const houseIndex = house.playersInside.indexOf(playerIndex);
                        if (houseIndex > -1) {
                            house.playersInside.splice(houseIndex, 1);
                        }
                        target.inHouse = null;
                        target.indoorPos = null;
                    }
                    
                    const shooterIndex = this.players.indexOf(shooter);
                    const targetIndex = this.players.indexOf(target);
                    
                    alert(`üéØ Player ${shooterIndex + 1} eliminated Player ${targetIndex + 1}!`);
                    
                    // Check win condition
                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        const winnerIndex = this.players.findIndex(p => p.alive);
                        alert(`üéâ üèÜ Player ${winnerIndex + 1} wins the game! üèÜ üéâ`);
                        this.gameActive = false;
                    }
                }
                
                this.updateUI();
            }
            
            showDamageEffect(target, damage) {
                // This would show a visual damage effect
                // For now, just update the UI
                console.log(`Damage dealt: ${damage}`);
            }
            
            pickupItem(player, x, y, indoor = false) {
                const weapons = ['pistol', 'rifle', 'shotgun', 'smg', 'flamethrower', 'sniper'];
                const gearTypes = ['armor', 'scope', 'medkit'];
                
                const isWeapon = Math.random() > 0.5;
                
                if (isWeapon) {
                    const newWeapon = weapons[Math.floor(Math.random() * weapons.length)];
                    const oldWeapon = player.weapon;
                    player.weapon = newWeapon;
                    
                    alert(`üî´ Found ${this.weapons[newWeapon].name}!\nReplaced your ${this.weapons[oldWeapon].name}`);
                } else {
                    const gearType = gearTypes[Math.floor(Math.random() * gearTypes.length)];
                    const gear = { ...this.gearTypes[gearType] };
                    
                    if (gearType === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + gear.value);
                        alert(`üíä Found Medkit!\nHealed ${gear.value} HP.`);
                    } else if (gearType === 'armor') {
                        player.armor = gear;
                        alert(`üõ°Ô∏è Found Body Armor!\nNow reduces damage by 30%`);
                    } else {
                        player.gear.push(gear);
                        alert(`üî≠ Found Scope!\n+${gear.value} to weapon range`);
                    }
                }
                
                // Remove item from map
                if (indoor) {
                    player.inHouse.indoorMap[y][x] = null;
                } else {
                    this.map[y][x] = null;
                }
            }
            
            endTurn() {
                // Reset turn state
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                // Find next alive player
                let attempts = 0;
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % 4;
                    attempts++;
                    if (attempts > 4) break; // Safety check
                } while (!this.players[this.currentPlayer].alive);
                
                // Update view for new player
                this.updateViewForCurrentPlayer();
                this.updateUI();
                this.draw();
                
                alert(`‚Ü™Ô∏è Turn passed to Player ${this.currentPlayer + 1}`);
            }
            
            updateViewForCurrentPlayer() {
                const currentPlayer = this.players[this.currentPlayer];
                
                if (currentPlayer.inHouse) {
                    this.currentHouse = currentPlayer.inHouse;
                    this.isIndoor = true;
                } else {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
            }
            
            updateUI() {
                // Update turn indicator
                this.currentPlayerNum.textContent = this.currentPlayer + 1;
                this.turnIndicator.style.borderColor = this.players[this.currentPlayer].color;
                
                // Update turn details
                let details = '';
                if (this.aiming) {
                    details = 'Aiming Mode';
                } else if (this.hasRolled) {
                    details = `${this.movesLeft} moves left`;
                } else if (this.players[this.currentPlayer].inHouse) {
                    details = 'Indoors - Roll not needed';
                } else {
                    details = 'Need to roll dice';
                }
                this.turnDetails.textContent = details;
                
                // Update player info panel
                const playersInfo = document.getElementById('players-info');
                playersInfo.innerHTML = '';
                
                this.players.forEach((player, index) => {
                    if (!player.alive) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'player-info';
                        playerDiv.innerHTML = `
                            <div class="player-header">
                                <span class="player-emoji">üíÄ</span>
                                <span class="player-name">Player ${index + 1} (Eliminated)</span>
                            </div>
                        `;
                        playersInfo.appendChild(playerDiv);
                        return;
                    }
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player-info ${index === this.currentPlayer ? 'current' : ''}`;
                    
                    const weapon = this.weapons[player.weapon];
                    const gearList = player.gear.map(g => g.emoji).join('');
                    const armorEmoji = player.armor ? player.armor.emoji : '';
                    
                    playerDiv.innerHTML = `
                        <div class="player-header">
                            <span class="player-emoji">${player.emoji}</span>
                            <span class="player-name">Player ${index + 1}</span>
                            ${player.inHouse ? '<span style="color:#9b59b6; font-size:12px;">üè†</span>' : ''}
                        </div>
                        <div class="player-hp">
                            <div class="player-hp-bar" style="width: ${(player.hp/player.maxHp)*100}%"></div>
                        </div>
                        <div class="player-stats">
                            <span>${weapon.emoji} ${weapon.name}</span>
                            <span>${armorEmoji} ${gearList}</span>
                            <span>‚ù§Ô∏è ${player.hp}</span>
                        </div>
                    `;
                    
                    playersInfo.appendChild(playerDiv);
                });
                
                // Update button states
                const rollBtn = document.querySelector('.action-btn.roll');
                const aimBtn = document.querySelector('.action-btn.aim');
                const shootBtn = document.querySelector('.action-btn.shoot');
                const endBtn = document.querySelector('.action-btn.end');
                
                const player = this.players[this.currentPlayer];
                
                rollBtn.disabled = this.hasRolled || this.aiming || player.inHouse;
                aimBtn.disabled = this.hasShot || this.aiming || (!this.hasRolled && !player.inHouse);
                shootBtn.disabled = !this.aiming;
                endBtn.disabled = false;
                
                // Visual feedback for disabled buttons
                [rollBtn, aimBtn, shootBtn, endBtn].forEach(btn => {
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                });
            }
            
            playSound(frequency, duration = 0.1, type = 'sine') {
                // Simple sound feedback
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    // Fallback for browsers without Web Audio API
                    console.log('Sound effect');
                }
            }
        }

        // Initialize game
        let game;

        function initGame() {
            game = new MobileBattleRoyale();
        }

        // Global functions for button actions
        function startMove(dx, dy) {
            if (game) game.startMove(dx, dy);
        }

        function stopMove() {
            if (game) game.stopMove();
        }

        function rollDice() {
            if (game) game.rollDice();
        }

        function enterAim() {
            if (game) game.enterAim();
        }

        function shoot() {
            if (game) game.shoot();
        }

        function endTurn() {
            if (game) game.endTurn();
        }

        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('active');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initGame);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
