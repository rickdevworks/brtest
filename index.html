<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        /* Landscape warning - unskippable */
        #landscape-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            text-align: center;
        }

        #landscape-warning h1 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #landscape-warning p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #landscape-warning .rotate-icon {
            font-size: 60px;
            margin: 20px 0;
            animation: rotate 2s infinite;
        }

        @keyframes rotate {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
        }

        /* Main container - optimized for mobile landscape */
        #game-container {
            display: none;
            width: 100%;
            height: 100%;
            padding: 2px; /* Small padding to account for browser UI */
            position: relative;
        }

        /* Canvas with safe area consideration */
        canvas {
            display: block;
            background: #2d3436;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            margin: 0 auto;
            width: calc(100vh * 0.9); /* Maintain aspect ratio */
            height: calc(100vh * 0.9); /* Square canvas based on height */
            max-width: 720px;
            max-height: 720px;
        }

        /* Touch controls panel */
        #controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 700px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(45, 52, 54, 0.9);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        /* Movement D-pad */
        #movement-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 8px;
            padding: 10px;
        }

        .movement-btn {
            width: 50px;
            height: 50px;
            background: #34495e;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .movement-btn:active {
            background: #2c3e50;
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .movement-btn.up { grid-area: up; }
        .movement-btn.left { grid-area: left; }
        .movement-btn.right { grid-area: right; }
        .movement-btn.down { grid-area: down; }

        /* Action buttons */
        #action-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
        }

        .action-btn {
            width: 120px;
            height: 45px;
            background: #3498db;
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .action-btn.roll { background: #f39c12; }
        .action-btn.aim { background: #e74c3c; }
        .action-btn.shoot { background: #c0392b; }
        .action-btn.end { background: #7f8c8d; }
        .action-btn.info { 
            width: 50px;
            background: #9b59b6;
        }

        /* Game info panel */
        #info-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 250px;
            max-height: 80vh;
            background: rgba(45, 52, 54, 0.95);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 99;
            display: none;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 2px solid #34495e;
        }

        #info-panel.active {
            display: block;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #34495e;
        }

        .panel-header h3 {
            font-size: 18px;
            color: #3498db;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .player-info {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .player-info.current {
            border-left: 4px solid #3498db;
            background: rgba(52, 73, 94, 0.8);
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .player-emoji {
            font-size: 20px;
        }

        .player-name {
            font-weight: 600;
        }

        .player-hp {
            width: 100%;
            height: 6px;
            background: #2c3e50;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }

        .player-hp-bar {
            height: 100%;
            background: #2ecc71;
            border-radius: 3px;
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #95a5a6;
        }

        .gear-list {
            margin-top: 15px;
        }

        .gear-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        .gear-emoji {
            font-size: 16px;
        }

        /* Turn indicator */
        #turn-indicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            text-align: center;
            z-index: 99;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
            border: 2px solid #3498db;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px #3498db; }
            50% { box-shadow: 0 0 20px #3498db; }
        }

        /* Aim overlay */
        #aim-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        .aim-cell {
            position: absolute;
            background: rgba(255, 255, 0, 0.3);
            border: 2px solid yellow;
            animation: pulse-aim 0.8s infinite;
        }

        @keyframes pulse-aim {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .shotgun-cell {
            position: absolute;
            background: rgba(255, 165, 0, 0.3);
            border: 2px solid orange;
        }

        /* Mobile optimization for different screen sizes */
        @media (max-height: 500px) {
            canvas {
                width: calc(100vh * 0.85);
                height: calc(100vh * 0.85);
            }
            
            .movement-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            .action-btn {
                width: 110px;
                height: 40px;
                font-size: 13px;
            }
            
            #info-panel {
                width: 200px;
            }
        }

        @media (min-height: 700px) {
            canvas {
                width: calc(100vh * 0.95);
                height: calc(100vh * 0.95);
            }
        }
    </style>
</head>
<body>
    <!-- Landscape warning -->
    <div id="landscape-warning">
        <h1>üîÑ Please Rotate Your Device</h1>
        <div class="rotate-icon">üì±</div>
        <p>This game is optimized for landscape mode.<br>Please rotate your device to play.</p>
        <p><small>If rotation doesn't work, check your device's orientation lock.</small></p>
    </div>

    <!-- Main game container -->
    <div id="game-container">
        <!-- Turn indicator -->
        <div id="turn-indicator">
            Player <span id="current-player-num">1</span>'s Turn
        </div>

        <!-- Game canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Info panel -->
        <div id="info-panel">
            <div class="panel-header">
                <h3>üìä Game Info</h3>
                <button class="close-btn" onclick="toggleInfoPanel()">‚úï</button>
            </div>
            <div id="players-info"></div>
            <div class="gear-list">
                <h4>üéÆ Controls</h4>
                <p style="font-size: 12px; margin-top: 5px; color: #95a5a6;">
                    1. <strong>Roll Dice</strong> to get movement points<br>
                    2. <strong>Move</strong> with D-pad<br>
                    3. <strong>Aim</strong> at target<br>
                    4. <strong>Shoot</strong> to attack<br>
                    5. <strong>End Turn</strong> when done
                </p>
            </div>
        </div>

        <!-- Touch controls -->
        <div id="controls">
            <!-- Movement D-pad -->
            <div id="movement-controls">
                <button class="movement-btn up" onclick="movePlayer(0, -1)">‚Üë</button>
                <button class="movement-btn left" onclick="movePlayer(-1, 0)">‚Üê</button>
                <button class="movement-btn right" onclick="movePlayer(1, 0)">‚Üí</button>
                <button class="movement-btn down" onclick="movePlayer(0, 1)">‚Üì</button>
            </div>

            <!-- Action buttons -->
            <div id="action-controls">
                <button class="action-btn roll" onclick="rollDice()">
                    <span>üé≤</span> Roll Dice
                </button>
                <button class="action-btn aim" onclick="enterAim()">
                    <span>üéØ</span> Aim
                </button>
                <button class="action-btn shoot" onclick="shoot()">
                    <span>üî´</span> Shoot
                </button>
                <button class="action-btn end" onclick="endTurn()">
                    <span>‚è≠Ô∏è</span> End Turn
                </button>
                <button class="action-btn info" onclick="toggleInfoPanel()">
                    ‚ÑπÔ∏è
                </button>
            </div>
        </div>

        <!-- Aim overlay -->
        <div id="aim-overlay"></div>
        <div id="shotgun-preview"></div>
    </div>

    <script>
        // Mobile optimization
        class MobileBattleRoyale {
            constructor() {
                // Core grid constants - optimized for mobile
                this.GRID_SIZE = 15;
                this.INDOOR_SIZE = 8;
                this.TILE_SIZE = 40; // Smaller for mobile screens
                this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                
                // Game elements
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.aimOverlay = document.getElementById('aim-overlay');
                this.shotgunPreview = document.getElementById('shotgun-preview');
                this.turnIndicator = document.getElementById('turn-indicator');
                this.currentPlayerNum = document.getElementById('current-player-num');
                
                // Setup canvas for mobile
                this.setupCanvas();
                
                // Game state
                this.gameActive = true;
                this.currentPlayer = 0;
                this.movesLeft = 0;
                this.hasRolled = false;
                this.hasShot = false;
                this.aiming = false;
                this.isIndoor = false;
                this.currentHouse = null;
                
                this.aim = {
                    x: null,
                    y: null,
                    dx: null,
                    dy: null,
                    steps: 0
                };
                
                // Initialize game
                this.initPlayers();
                this.initMap();
                this.initWeapons();
                this.initGear();
                this.updateUI();
                this.draw();
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();
                
                // Check orientation on load
                this.checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.checkOrientation(), 100);
                });
            }
            
            setupCanvas() {
                // Set canvas size for mobile optimization
                this.canvas.width = this.CANVAS_SIZE;
                this.canvas.height = this.CANVAS_SIZE;
                
                // Setup context
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            handleResize() {
                // Adjust for browser UI (address bar)
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                const screenHeight = window.innerHeight;
                const screenWidth = window.innerWidth;
                
                // Adjust controls position based on screen size
                const controls = document.getElementById('controls');
                if (screenHeight < 500) {
                    controls.style.bottom = '5px';
                    controls.style.padding = '8px';
                } else {
                    controls.style.bottom = '10px';
                    controls.style.padding = '10px';
                }
                
                // Adjust canvas size for very small screens
                if (screenHeight < 400) {
                    this.TILE_SIZE = 32;
                    this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                    this.canvas.width = this.CANVAS_SIZE;
                    this.canvas.height = this.CANVAS_SIZE;
                } else if (screenHeight > 700) {
                    this.TILE_SIZE = 48;
                    this.CANVAS_SIZE = this.GRID_SIZE * this.TILE_SIZE;
                    this.canvas.width = this.CANVAS_SIZE;
                    this.canvas.height = this.CANVAS_SIZE;
                }
                
                if (this.gameActive) {
                    this.draw();
                }
            }
            
            checkOrientation() {
                const warning = document.getElementById('landscape-warning');
                const gameContainer = document.getElementById('game-container');
                
                // Check if device is in landscape
                const isLandscape = window.innerWidth > window.innerHeight;
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isLandscape || !isMobile) {
                    warning.style.display = 'none';
                    gameContainer.style.display = 'block';
                } else {
                    warning.style.display = 'flex';
                    gameContainer.style.display = 'none';
                }
            }
            
            initPlayers() {
                this.players = [
                    {
                        x: 0, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üòé',
                        color: '#3498db'
                    },
                    {
                        x: 0, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü§†',
                        color: '#e74c3c'
                    },
                    {
                        x: 14, y: 0,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'ü¶π',
                        color: '#2ecc71'
                    },
                    {
                        x: 14, y: 14,
                        hp: 100, maxHp: 100,
                        weapon: 'pistol',
                        armor: null,
                        gear: [],
                        alive: true,
                        inHouse: null,
                        indoorPos: null,
                        emoji: 'üßô',
                        color: '#f39c12'
                    }
                ];
            }
            
            initMap() {
                this.map = [];
                this.houses = [];
                
                // Create 15x15 grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    this.map[y] = [];
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const r = Math.random();
                        
                        if (r < 0.08) {
                            this.map[y][x] = { type: 'üå≥', blocks: true, cover: true };
                        } else if (r < 0.14) {
                            this.map[y][x] = { type: 'ü™®', blocks: true, cover: true };
                        } else if (r < 0.16) {
                            this.map[y][x] = { type: 'üè†', blocks: false, house: true };
                            this.houses.push({
                                x: x, y: y,
                                entranceX: x, entranceY: y,
                                indoorMap: this.createIndoorMap(),
                                playersInside: []
                            });
                        } else if (r < 0.20) {
                            this.map[y][x] = { type: 'üì¶', blocks: false, item: true };
                        } else {
                            this.map[y][x] = null;
                        }
                    }
                }
                
                // Clear corners for spawn points
                const corners = [[0,14], [0,0], [14,0], [14,14]];
                corners.forEach(([x,y]) => {
                    this.map[y][x] = null;
                });
            }
            
            createIndoorMap() {
                const indoorSize = 8;
                const indoorMap = [];
                
                for (let y = 0; y < indoorSize; y++) {
                    indoorMap[y] = [];
                    for (let x = 0; x < indoorSize; x++) {
                        indoorMap[y][x] = null;
                    }
                }
                
                // Place door
                const doorX = Math.floor(indoorSize / 2) - 1;
                const doorY = indoorSize - 1;
                indoorMap[doorY][doorX] = { type: 'üö™', blocks: false, door: true };
                
                // Walls
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        if (x === 0 || y === 0 || x === indoorSize-1 || y === indoorSize-1) {
                            if (x === doorX && y === doorY) continue;
                            indoorMap[y][x] = { type: 'üß±', blocks: true };
                        }
                    }
                }
                
                // Furniture and items
                const furniture = ['üõãÔ∏è', 'üì∫', 'ü™ë', 'üõèÔ∏è'];
                const foodItems = ['üçé', 'üçó', 'ü•§'];
                
                for (let y = 1; y < indoorSize - 1; y++) {
                    for (let x = 1; x < indoorSize - 1; x++) {
                        if (x >= doorX-1 && x <= doorX+1 && y >= doorY-1) continue;
                        
                        const r = Math.random();
                        if (r < 0.25) {
                            indoorMap[y][x] = { type: furniture[Math.floor(Math.random()*furniture.length)], blocks: true };
                        } else if (r < 0.28) {
                            const food = foodItems[Math.floor(Math.random()*foodItems.length)];
                            indoorMap[y][x] = { 
                                type: food, 
                                blocks: false, 
                                food: true,
                                healAmount: { 'üçé':15, 'üçó':25, 'ü•§':20 }[food]
                            };
                        } else if (r < 0.33) {
                            indoorMap[y][x] = { type: 'üì¶', blocks: false, item: true };
                        }
                    }
                }
                
                return indoorMap;
            }
            
            initWeapons() {
                this.weapons = {
                    pistol: { name: 'Pistol', damage: 20, range: 4, emoji: 'üî´', type: 'linear' },
                    rifle: { name: 'Rifle', damage: 30, range: 8, emoji: 'üéØ', type: 'linear' },
                    shotgun: { name: 'Shotgun', damage: 40, range: 2, emoji: 'üî´', type: 'shotgun' },
                    smg: { name: 'SMG', damage: 15, range: 3, emoji: 'üî´', type: 'rapid' },
                    flamethrower: { name: 'Flamethrower', damage: 25, range: 2, emoji: 'üî•', type: 'flame' },
                    sniper: { name: 'Sniper', damage: 50, range: 12, emoji: 'üéØ', type: 'linear' }
                };
            }
            
            initGear() {
                this.gearTypes = {
                    armor: { name: 'Body Armor', effect: 'damageReduction', value: 0.3, emoji: 'üõ°Ô∏è' },
                    scope: { name: 'Scope', effect: 'rangeBonus', value: 2, emoji: 'üî≠' },
                    medkit: { name: 'Medkit', effect: 'heal', value: 30, emoji: 'üíä' }
                };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.isIndoor && this.currentHouse) {
                    this.drawIndoor();
                } else {
                    this.drawOutdoor();
                }
            }
            
            drawOutdoor() {
                // Draw grass background
                this.ctx.fillStyle = '#2e7d32';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                for (let y = 0; y < this.GRID_SIZE; y++) {
                    for (let x = 0; x < this.GRID_SIZE; x++) {
                        const tile = this.map[y][x];
                        const screenX = x * this.TILE_SIZE;
                        const screenY = y * this.TILE_SIZE;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#3a7d44';
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse) return;
                    this.drawPlayer(player, index, player.x, player.y);
                });
            }
            
            drawIndoor() {
                if (!this.currentHouse) return;
                
                // Draw wooden floor
                this.ctx.fillStyle = '#8b4513';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const indoorSize = 8;
                const offsetX = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                const offsetY = (this.GRID_SIZE - indoorSize) * this.TILE_SIZE / 2;
                
                for (let y = 0; y < indoorSize; y++) {
                    for (let x = 0; x < indoorSize; x++) {
                        const tile = this.currentHouse.indoorMap[y][x];
                        const screenX = x * this.TILE_SIZE + offsetX;
                        const screenY = y * this.TILE_SIZE + offsetY;
                        
                        // Grid lines
                        this.ctx.strokeStyle = '#a0522d';
                        this.ctx.strokeRect(screenX, screenY, this.TILE_SIZE, this.TILE_SIZE);
                        
                        if (tile) {
                            this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                            this.ctx.fillText(
                                tile.type,
                                screenX + this.TILE_SIZE / 2,
                                screenY + this.TILE_SIZE / 2
                            );
                        }
                    }
                }
                
                // Draw indoor players
                this.players.forEach((player, index) => {
                    if (!player.alive || player.inHouse !== this.currentHouse) return;
                    this.drawPlayer(player, index, player.indoorPos.x, player.indoorPos.y, offsetX, offsetY);
                });
            }
            
            drawPlayer(player, index, gridX, gridY, offsetX = 0, offsetY = 0) {
                const screenX = gridX * this.TILE_SIZE + offsetX;
                const screenY = gridY * this.TILE_SIZE + offsetY;
                
                // Draw player circle
                this.ctx.fillStyle = player.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2,
                    this.TILE_SIZE / 2 - 4,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
                
                // Pulsing for current player
                if (index === this.currentPlayer) {
                    this.ctx.save();
                    const pulseScale = 1 + 0.1 * Math.sin(Date.now() / 200);
                    this.ctx.translate(screenX + this.TILE_SIZE / 2, screenY + this.TILE_SIZE / 2);
                    this.ctx.scale(pulseScale, pulseScale);
                    this.ctx.translate(-(screenX + this.TILE_SIZE / 2), -(screenY + this.TILE_SIZE / 2));
                    
                    this.ctx.shadowColor = player.color;
                    this.ctx.shadowBlur = 10;
                }
                
                // Player emoji
                this.ctx.font = `${this.TILE_SIZE * 0.6}px Arial`;
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText(
                    player.emoji,
                    screenX + this.TILE_SIZE / 2,
                    screenY + this.TILE_SIZE / 2
                );
                
                if (index === this.currentPlayer) {
                    this.ctx.restore();
                }
                
                // Health bar
                const barWidth = this.TILE_SIZE - 8;
                const barHeight = 4;
                const barX = screenX + 4;
                const barY = screenY - 6;
                
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = player.hp / player.maxHp;
                const healthWidth = healthPercent * barWidth;
                
                this.ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : 
                                   healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
            }
            
            // Game actions
            rollDice() {
                if (this.hasRolled || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (player.inHouse) {
                    this.movesLeft = 99; // Infinite moves indoors
                } else {
                    this.movesLeft = Math.floor(Math.random() * 6) + 1 + 
                                    Math.floor(Math.random() * 6) + 1;
                }
                
                this.hasRolled = true;
                this.updateUI();
                this.playSound(500);
                alert(`üé≤ Rolled ${this.movesLeft} moves!`);
            }
            
            movePlayer(dx, dy) {
                if (!this.gameActive) return;
                if (this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (player.inHouse) {
                    this.movePlayerIndoor(player, dx, dy);
                } else {
                    if (this.movesLeft <= 0 && this.hasRolled) return;
                    this.movePlayerOutdoor(player, dx, dy);
                }
            }
            
            movePlayerOutdoor(player, dx, dy) {
                const newX = player.x + dx;
                const newY = player.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= this.GRID_SIZE || newY >= this.GRID_SIZE) {
                    return;
                }
                
                const tile = this.map[newY][newX];
                
                if (!tile) {
                    const collision = this.players.some(p => 
                        p.alive && p !== player && !p.inHouse && p.x === newX && p.y === newY);
                    if (collision) return;
                    
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.updateUI();
                    this.draw();
                    this.playSound(300);
                    return;
                }
                
                if (tile.blocks) return;
                
                if (tile.house) {
                    this.enterHouse(player, newX, newY);
                    return;
                }
                
                if (tile.item) {
                    player.x = newX;
                    player.y = newY;
                    if (this.hasRolled) this.movesLeft--;
                    this.pickupItem(player, newX, newY);
                    this.updateUI();
                    this.draw();
                    this.playSound(600);
                    return;
                }
            }
            
            movePlayerIndoor(player, dx, dy) {
                if (!player.indoorPos) return;
                
                const newX = player.indoorPos.x + dx;
                const newY = player.indoorPos.y + dy;
                
                if (newX < 0 || newY < 0 || newX >= 8 || newY >= 8) return;
                
                const tile = player.inHouse.indoorMap[newY][newX];
                
                if (!tile) {
                    const collision = this.players.find(p => 
                        p.alive && p !== player && 
                        p.inHouse === player.inHouse &&
                        p.indoorPos && p.indoorPos.x === newX && p.indoorPos.y === newY);
                    
                    if (collision) return;
                    
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.updateUI();
                    this.drawIndoor();
                    this.playSound(300);
                    return;
                }
                
                if (tile.blocks) return;
                
                if (tile.door) {
                    this.exitHouse(player);
                    return;
                }
                
                if (tile.food) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    player.hp = Math.min(player.maxHp, player.hp + tile.healAmount);
                    player.inHouse.indoorMap[newY][newX] = null;
                    this.updateUI();
                    this.drawIndoor();
                    this.playSound(700);
                    alert(`üçó Healed ${tile.healAmount} HP!`);
                    return;
                }
                
                if (tile.item) {
                    player.indoorPos.x = newX;
                    player.indoorPos.y = newY;
                    this.pickupItem(player, newX, newY, true);
                    this.updateUI();
                    this.drawIndoor();
                    this.playSound(600);
                    return;
                }
            }
            
            enterHouse(player, houseX, houseY) {
                const house = this.houses.find(h => h.x === houseX && h.y === houseY);
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const doorX = 3;
                const doorY = 7;
                
                player.inHouse = house;
                player.indoorPos = { x: doorX, y: doorY };
                house.playersInside.push(playerIndex);
                
                this.currentHouse = house;
                this.isIndoor = true;
                this.movesLeft = 99;
                this.hasRolled = true;
                
                this.updateUI();
                this.drawIndoor();
                this.playSound(800);
                alert(`üè† Player ${playerIndex + 1} entered the house!`);
            }
            
            exitHouse(player) {
                const house = player.inHouse;
                if (!house) return;
                
                const playerIndex = this.players.indexOf(player);
                const houseIndex = house.playersInside.indexOf(playerIndex);
                
                if (houseIndex > -1) {
                    house.playersInside.splice(houseIndex, 1);
                }
                
                player.x = house.entranceX;
                player.y = house.entranceY;
                player.inHouse = null;
                player.indoorPos = null;
                
                if (house.playersInside.length === 0) {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
                
                this.updateViewForCurrentPlayer();
                this.playSound(600);
                alert(`üö™ Player ${playerIndex + 1} exited the house!`);
            }
            
            enterAim() {
                if (this.hasShot || this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                
                if (this.isIndoor && player.indoorPos) {
                    this.aim = {
                        x: player.indoorPos.x,
                        y: player.indoorPos.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                } else {
                    this.aim = {
                        x: player.x,
                        y: player.y,
                        dx: null,
                        dy: null,
                        steps: 0
                    };
                }
                
                this.aiming = true;
                this.updateAimCursor();
            }
            
            moveAim(dx, dy) {
                if (!this.aiming) return;
                
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                let range = weapon.range;
                player.gear.forEach(g => {
                    if (g.effect === 'rangeBonus') range += g.value;
                });
                
                if (this.aim.dx === null && this.aim.dy === null) {
                    this.aim.dx = dx;
                    this.aim.dy = dy;
                }
                
                if (dx !== this.aim.dx || dy !== this.aim.dy) return;
                if (this.aim.steps >= range) return;
                
                const newX = this.aim.x + dx;
                const newY = this.aim.y + dy;
                
                const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                if (newX < 0 || newY < 0 || newX >= maxBound || newY >= maxBound) return;
                
                this.aim.x = newX;
                this.aim.y = newY;
                this.aim.steps++;
                
                this.updateAimCursor();
                this.playSound(400);
            }
            
            updateAimCursor() {
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                if (!this.aiming) return;
                
                let screenX, screenY;
                
                if (this.isIndoor) {
                    const offsetX = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    const offsetY = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                    screenX = this.aim.x * this.TILE_SIZE + offsetX;
                    screenY = this.aim.y * this.TILE_SIZE + offsetY;
                } else {
                    screenX = this.aim.x * this.TILE_SIZE;
                    screenY = this.aim.y * this.TILE_SIZE;
                }
                
                const cursor = document.createElement('div');
                cursor.className = 'aim-cell';
                cursor.style.left = screenX + 'px';
                cursor.style.top = screenY + 'px';
                cursor.style.width = this.TILE_SIZE + 'px';
                cursor.style.height = this.TILE_SIZE + 'px';
                
                this.aimOverlay.appendChild(cursor);
                
                // Shotgun preview
                const player = this.players[this.currentPlayer];
                const weapon = this.weapons[player.weapon];
                
                if (weapon.type === 'shotgun' && this.aim.dx !== null) {
                    const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                    
                    patterns.forEach(([dx, dy]) => {
                        const x = this.aim.x + dx;
                        const y = this.aim.y + dy;
                        
                        const maxBound = this.isIndoor ? 8 : this.GRID_SIZE;
                        if (x < 0 || y < 0 || x >= maxBound || y >= maxBound) return;
                        
                        let cellX, cellY;
                        if (this.isIndoor) {
                            const offset = (this.GRID_SIZE - 8) * this.TILE_SIZE / 2;
                            cellX = x * this.TILE_SIZE + offset;
                            cellY = y * this.TILE_SIZE + offset;
                        } else {
                            cellX = x * this.TILE_SIZE;
                            cellY = y * this.TILE_SIZE;
                        }
                        
                        const cell = document.createElement('div');
                        cell.className = 'shotgun-cell';
                        cell.style.left = cellX + 'px';
                        cell.style.top = cellY + 'px';
                        cell.style.width = this.TILE_SIZE + 'px';
                        cell.style.height = this.TILE_SIZE + 'px';
                        
                        this.shotgunPreview.appendChild(cell);
                    });
                }
            }
            
            getShotgunPattern(dx, dy) {
                if (dx !== 0 && dy === 0) {
                    return [[dx,0], [dx,-1], [dx,1]];
                }
                if (dy !== 0 && dx === 0) {
                    return [[0,dy], [-1,dy], [1,dy]];
                }
                return [[dx, dy]];
            }
            
            shoot() {
                if (!this.aiming || this.hasShot) return;
                
                const shooter = this.players[this.currentPlayer];
                const weapon = this.weapons[shooter.weapon];
                
                switch (weapon.type) {
                    case 'linear':
                        this.fireLinear(shooter, weapon);
                        break;
                    case 'shotgun':
                        this.fireShotgun(shooter, weapon);
                        break;
                    case 'rapid':
                        this.fireRapid(shooter, weapon);
                        break;
                    case 'flame':
                        this.fireFlamethrower(shooter, weapon);
                        break;
                }
                
                this.hasShot = true;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                this.updateUI();
                this.draw();
            }
            
            findTargetAt(shooter, targetX, targetY) {
                if (this.isIndoor) {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        p.inHouse === shooter.inHouse &&
                        p.indoorPos && p.indoorPos.x === targetX && p.indoorPos.y === targetY
                    );
                } else {
                    return this.players.find(p => 
                        p.alive && p !== shooter &&
                        !p.inHouse && p.x === targetX && p.y === targetY
                    );
                }
            }
            
            fireLinear(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    return;
                }
                
                if (!this.checkLineOfSight(shooter, target)) {
                    alert('Shot blocked!');
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
            }
            
            fireShotgun(shooter, weapon) {
                if (this.aim.dx === null) return;
                
                const patterns = this.getShotgunPattern(this.aim.dx, this.aim.dy);
                let hitCount = 0;
                
                patterns.forEach(([dx, dy]) => {
                    const targetX = this.aim.x + dx;
                    const targetY = this.aim.y + dy;
                    
                    const target = this.findTargetAt(shooter, targetX, targetY);
                    if (!target) return;
                    if (!this.checkLineOfSight(shooter, target)) return;
                    
                    const pelletDamage = Math.floor(weapon.damage / 2);
                    this.applyDamage(shooter, target, pelletDamage);
                    hitCount++;
                });
                
                if (hitCount > 0) {
                    this.playSound(300, 0.2);
                } else {
                    this.playSound(200, 0.1);
                }
            }
            
            fireRapid(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target || !this.checkLineOfSight(shooter, target)) {
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                
                setTimeout(() => {
                    if (target.alive) {
                        this.applyDamage(shooter, target, weapon.damage);
                    }
                }, 200);
                
                this.playSound(400, 0.3);
            }
            
            fireFlamethrower(shooter, weapon) {
                const target = this.findTargetAt(shooter, this.aim.x, this.aim.y);
                
                if (!target) {
                    this.playSound(200, 0.1);
                    return;
                }
                
                this.applyDamage(shooter, target, weapon.damage);
                this.playSound(200, 0.4);
            }
            
            checkLineOfSight(shooter, target) {
                const weapon = this.weapons[shooter.weapon];
                if (weapon.type === 'flame') return true;
                
                let x1, y1, x2, y2, map;
                
                if (this.isIndoor) {
                    x1 = shooter.indoorPos.x;
                    y1 = shooter.indoorPos.y;
                    x2 = target.indoorPos.x;
                    y2 = target.indoorPos.y;
                    map = this.currentHouse.indoorMap;
                } else {
                    x1 = shooter.x;
                    y1 = shooter.y;
                    x2 = target.x;
                    y2 = target.y;
                    map = this.map;
                }
                
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                let x = x1;
                let y = y1;
                
                while (true) {
                    if (x !== x1 || y !== y1) {
                        if (map[y] && map[y][x] && map[y][x].blocks) {
                            return false;
                        }
                    }
                    
                    if (x === x2 && y === y2) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return true;
            }
            
            applyDamage(shooter, target, baseDamage) {
                let finalDamage = baseDamage;
                
                if (target.armor && target.armor.effect === 'damageReduction') {
                    finalDamage = Math.floor(baseDamage * (1 - target.armor.value));
                }
                
                target.hp -= finalDamage;
                this.playSound(400 + finalDamage * 2);
                
                if (target.hp <= 0) {
                    target.alive = false;
                    target.hp = 0;
                    
                    if (target.inHouse) {
                        const house = target.inHouse;
                        const playerIndex = this.players.indexOf(target);
                        const houseIndex = house.playersInside.indexOf(playerIndex);
                        if (houseIndex > -1) {
                            house.playersInside.splice(houseIndex, 1);
                        }
                        target.inHouse = null;
                        target.indoorPos = null;
                    }
                    
                    const shooterIndex = this.players.indexOf(shooter);
                    const targetIndex = this.players.indexOf(target);
                    
                    alert(`üéØ Player ${shooterIndex + 1} eliminated Player ${targetIndex + 1}!`);
                    
                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        const winnerIndex = this.players.findIndex(p => p.alive);
                        alert(`üéâ üèÜ Player ${winnerIndex + 1} wins! üèÜ üéâ`);
                        this.gameActive = false;
                    }
                }
                
                this.updateUI();
            }
            
            pickupItem(player, x, y, indoor = false) {
                const items = ['pistol', 'rifle', 'shotgun', 'smg', 'flamethrower', 'sniper'];
                const gears = ['armor', 'scope', 'medkit'];
                
                const isWeapon = Math.random() > 0.5;
                
                if (isWeapon) {
                    const newWeapon = items[Math.floor(Math.random() * items.length)];
                    player.weapon = newWeapon;
                    alert(`üî´ Found ${this.weapons[newWeapon].name}!`);
                } else {
                    const gearType = gears[Math.floor(Math.random() * gears.length)];
                    const gear = { ...this.gearTypes[gearType] };
                    
                    if (gearType === 'medkit') {
                        player.hp = Math.min(player.maxHp, player.hp + gear.value);
                        alert(`üíä Used Medkit! Healed ${gear.value} HP.`);
                    } else {
                        if (gearType === 'armor') {
                            player.armor = gear;
                        } else {
                            player.gear.push(gear);
                        }
                        alert(`üéí Found ${gear.name}!`);
                    }
                }
                
                if (indoor) {
                    player.inHouse.indoorMap[y][x] = null;
                } else {
                    this.map[y][x] = null;
                }
            }
            
            endTurn() {
                this.movesLeft = 0;
                this.hasShot = false;
                this.hasRolled = false;
                this.aiming = false;
                this.aim = { x: null, y: null, dx: null, dy: null, steps: 0 };
                this.aimOverlay.innerHTML = '';
                this.shotgunPreview.innerHTML = '';
                
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % 4;
                } while (!this.players[this.currentPlayer].alive);
                
                this.updateViewForCurrentPlayer();
                this.updateUI();
                this.draw();
            }
            
            updateViewForCurrentPlayer() {
                const currentPlayer = this.players[this.currentPlayer];
                
                if (currentPlayer.inHouse) {
                    this.currentHouse = currentPlayer.inHouse;
                    this.isIndoor = true;
                } else {
                    this.currentHouse = null;
                    this.isIndoor = false;
                }
            }
            
            updateUI() {
                // Update turn indicator
                this.currentPlayerNum.textContent = this.currentPlayer + 1;
                this.turnIndicator.style.borderColor = this.players[this.currentPlayer].color;
                
                // Update player info panel
                const playersInfo = document.getElementById('players-info');
                playersInfo.innerHTML = '';
                
                this.players.forEach((player, index) => {
                    if (!player.alive) return;
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player-info ${index === this.currentPlayer ? 'current' : ''}`;
                    
                    const weapon = this.weapons[player.weapon];
                    const gearList = player.gear.map(g => g.emoji).join('');
                    const armorEmoji = player.armor ? player.armor.emoji : '';
                    
                    playerDiv.innerHTML = `
                        <div class="player-header">
                            <span class="player-emoji">${player.emoji}</span>
                            <span class="player-name">Player ${index + 1}</span>
                        </div>
                        <div class="player-hp">
                            <div class="player-hp-bar" style="width: ${(player.hp/player.maxHp)*100}%"></div>
                        </div>
                        <div class="player-stats">
                            <span>${weapon.emoji} ${weapon.name}</span>
                            <span>${armorEmoji} ${gearList}</span>
                            <span>‚ù§Ô∏è ${player.hp}/${player.maxHp}</span>
                        </div>
                    `;
                    
                    playersInfo.appendChild(playerDiv);
                });
                
                // Update button states
                const rollBtn = document.querySelector('.action-btn.roll');
                const aimBtn = document.querySelector('.action-btn.aim');
                const shootBtn = document.querySelector('.action-btn.shoot');
                
                rollBtn.disabled = this.hasRolled || this.aiming;
                aimBtn.disabled = this.hasShot || this.aiming || (this.hasRolled && this.movesLeft > 0);
                shootBtn.disabled = !this.aiming;
                
                // Update moves display in turn indicator
                const movesText = this.movesLeft > 0 ? ` (${this.movesLeft} moves left)` : '';
                this.turnIndicator.innerHTML = `
                    Player ${this.currentPlayer + 1}'s Turn${movesText}
                    ${this.aiming ? '<br><small>Aiming Mode Active</small>' : ''}
                `;
            }
            
            playSound(frequency, duration = 0.1, type = 'sine') {
                // Simple Web Audio API for mobile-friendly sounds
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    // Fallback for browsers without Web Audio API
                    console.log('Sound:', frequency);
                }
            }
        }

        // Initialize game when page loads
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new MobileBattleRoyale();
            
            // Add touch controls for aim movement
            document.querySelector('.movement-btn.up').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.aiming) game.moveAim(0, -1);
            });
            
            document.querySelector('.movement-btn.left').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.aiming) game.moveAim(-1, 0);
            });
            
            document.querySelector('.movement-btn.right').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.aiming) game.moveAim(1, 0);
            });
            
            document.querySelector('.movement-btn.down').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.aiming) game.moveAim(0, 1);
            });
            
            // Prevent context menu on long press
            document.addEventListener('contextmenu', e => e.preventDefault());
        });

        // Global function to toggle info panel
        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('active');
        }

        // Global functions for button actions
        function movePlayer(dx, dy) {
            if (game.aiming) {
                game.moveAim(dx, dy);
            } else {
                game.movePlayer(dx, dy);
            }
        }

        function rollDice() { game.rollDice(); }
        function enterAim() { game.enterAim(); }
        function shoot() { game.shoot(); }
        function endTurn() { game.endTurn(); }
    </script>
</body>
</html>
